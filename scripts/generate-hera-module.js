#!/usr/bin/env node

/**
 * HERA Hook-Driven Module Generator
 * 
 * "One-Go Build" generator that emits:
 * - Enhanced HERA client methods
 * - React hooks (useOrg, useHeraQuery, entity hooks)
 * - API v2 read routes with RLS guards
 * - Shared org-aware pages
 * - Test suites (guardrails, RLS, actor stamping)
 * 
 * Everything talks to API v2 gateway with org context, guardrails, RLS, and actor stamping
 */

const fs = require('fs')
const path = require('path')
const yaml = require('js-yaml')

// Entity presets with Smart Code patterns
const ENTITY_PRESETS = {
  customers: {
    entityType: 'CUSTOMER',
    smartCodeBase: 'HERA.RETAIL.CUSTOMER',
    module: 'retail',
    route: '/retail/customers',
    icon: 'Users',
    color: '#3B82F6',
    description: 'Customer management with multi-tenant field configuration'
  },
  products: {
    entityType: 'PRODUCT',
    smartCodeBase: 'HERA.RETAIL.PRODUCT',
    module: 'retail',
    route: '/retail/products',
    icon: 'Package',
    color: '#10B981',
    description: 'Product catalog with inventory integration'
  },
  accounts: {
    entityType: 'ACCOUNT',
    smartCodeBase: 'HERA.CRM.ACCOUNT',
    module: 'crm',
    route: '/crm/accounts',
    icon: 'Building2',
    color: '#8B5CF6',
    description: 'Company accounts and organizations'
  },
  contacts: {
    entityType: 'CONTACT',
    smartCodeBase: 'HERA.CRM.CONTACT',
    module: 'crm',
    route: '/crm/contacts',
    icon: 'User',
    color: '#F59E0B',
    description: 'Individual contacts with GDPR compliance'
  },
  leads: {
    entityType: 'LEAD',
    smartCodeBase: 'HERA.CRM.LEAD',
    module: 'crm',
    route: '/crm/leads',
    icon: 'Target',
    color: '#EF4444',
    description: 'Sales prospects with scoring and conversion tracking'
  }
}

function generateModule(entityName, module, options = {}) {
  const preset = ENTITY_PRESETS[entityName.toLowerCase()]
  if (!preset) {
    console.error(`‚ùå Unknown entity preset: ${entityName}`)
    console.log(`Available presets: ${Object.keys(ENTITY_PRESETS).join(', ')}`)
    process.exit(1)
  }

  const config = {
    ...preset,
    moduleName: module || preset.module,
    entityName: entityName.toLowerCase(),
    EntityName: capitalize(entityName),
    ENTITY_TYPE: preset.entityType,
    timestamp: new Date().toISOString(),
    ...options
  }

  console.log(`üöÄ Generating HERA module: ${config.EntityName}`)
  console.log(`üì¶ Module: ${config.moduleName}`)
  console.log(`üéØ Entity Type: ${config.ENTITY_TYPE}`)
  console.log(`üîó Route: ${config.route}`)

  // Generate all components
  const files = [
    generateEntityHooks(config),
    generateAPIRoute(config),
    generateAPIRouteById(config),
    generatePage(config),
    generateGuardrailsTests(config),
    generateRLSTests(config),
    generateActorTests(config)
  ]

  // Write all files
  files.forEach(({ filePath, content }) => {
    const dir = path.dirname(filePath)
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }
    fs.writeFileSync(filePath, content)
    console.log(`‚úÖ Created: ${filePath}`)
  })

  // Update package.json scripts if needed
  updatePackageScripts(config)

  console.log(`\nüéâ Module generation complete!`)
  console.log(`\nüìã Next steps:`)
  console.log(`1. Review generated files`)
  console.log(`2. Run: npm run test:${config.entityName}`)
  console.log(`3. Navigate to: ${config.route}`)
  console.log(`4. Test with different organizations`)
}

// Generate entity-specific hooks
function generateEntityHooks(config) {
  const content = `/**
 * ${config.EntityName} Entity Hooks
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Provides complete CRUD operations with:
 * - RLS-scoped reads via API routes
 * - API v2 command writes with actor stamping  
 * - Smart Code validation built-in
 * - Automatic cache invalidation on mutations
 */

'use client'

import { useCallback, useState, useEffect } from 'react'
import { useHeraEntityListQuery, useHeraEntityQuery, useHeraCacheControl, useHeraQuery } from './useHeraQuery'
import { heraCommand } from '@/lib/hera/client'
import { useOrg } from './useOrg'
import { getFieldConfiguration, validateFormData, formDataToDynamicFields } from '@/lib/field-config'

export interface ${config.EntityName} {
  entity_id: string
  entity_name: string
  entity_type: '${config.ENTITY_TYPE}'
  smart_code: string
  created_at: string
  updated_at: string
  created_by: string
  updated_by: string
  dynamic_fields: Record<string, {
    field_value_text?: string
    field_value_number?: number
    field_value_boolean?: boolean
    field_value_json?: any
    smart_code: string
  }>
  relationships?: Array<{
    relationship_type: string
    target_entity_id: string
    target_entity_name: string
  }>
}

export interface ${config.EntityName}ListParams {
  search?: string
  limit?: number
  offset?: number
  sort?: string
  order?: 'asc' | 'desc'
}

export interface Create${config.EntityName}Input {
  entity_name: string
  dynamic_fields?: Record<string, any>
}

export interface Update${config.EntityName}Input {
  entity_name?: string
  dynamic_fields?: Record<string, any>
}

/**
 * Hook for listing ${config.entityName} with search and pagination
 * Uses RLS-scoped API endpoint for secure data access
 */
export function use${config.EntityName}s(params: ${config.EntityName}ListParams = {}) {
  return useHeraEntityListQuery<${config.EntityName}>(
    '${config.entityName}',
    {
      search: params.search || '',
      limit: params.limit || 50,
      offset: params.offset || 0,
      sort: params.sort || 'entity_name',
      order: params.order || 'asc'
    },
    {
      requireAuth: true,
      requireOrg: true,
      requireMembership: true,
      revalidateOnFocus: false,
      dedupingInterval: 30000 // Cache for 30 seconds
    }
  )
}

/**
 * Hook for fetching a single ${config.entityName} by ID
 * Uses RLS-scoped API endpoint
 */
export function use${config.EntityName}(${config.entityName}Id?: string) {
  return useHeraEntityQuery<${config.EntityName}>(
    '${config.entityName}',
    ${config.entityName}Id,
    {
      requireAuth: true,
      requireOrg: true,
      requireMembership: true,
      revalidateOnFocus: false,
      dedupingInterval: 60000 // Cache for 1 minute
    }
  )
}

/**
 * Hook for ${config.entityName} mutation operations (CREATE/UPDATE/DELETE)
 * All operations go through API v2 command interface with actor stamping
 */
export function use${config.EntityName}Mutations() {
  const { orgId } = useOrg()
  const { invalidateEntity } = useHeraCacheControl()

  const create${config.EntityName} = useCallback(async (input: Create${config.EntityName}Input) => {
    if (!orgId) {
      throw new Error('No organization context available')
    }

    // Get field configuration for validation
    const token = typeof window !== 'undefined' ? 
      (window as any).__HERA_JWT__ : ''
    const fieldConfig = await getFieldConfiguration('${config.ENTITY_TYPE}', orgId, token)
    
    // Validate form data
    const formData = {
      entity_name: input.entity_name,
      ...input.dynamic_fields
    }
    const errors = validateFormData(fieldConfig.fields, formData)
    
    if (Object.keys(errors).length > 0) {
      throw new Error(\`Validation failed: \${Object.values(errors).join(', ')}\`)
    }

    // Convert to dynamic fields format
    const dynamicFields = formDataToDynamicFields(fieldConfig.fields, formData)

    // Prepare API v2 command
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: input.entity_name,
        smart_code: "${config.smartCodeBase}.v1",
        organization_id: orgId,
        dynamic_fields: dynamicFields
      }
    }

    const result = await heraCommand(payload, { orgId })

    // Invalidate cache
    await invalidateEntity('${config.entityName}')

    return result
  }, [orgId, invalidateEntity])

  const update${config.EntityName} = useCallback(async (
    ${config.entityName}Id: string, 
    input: Update${config.EntityName}Input
  ) => {
    if (!orgId) {
      throw new Error('No organization context available')
    }

    // Get field configuration for validation
    const token = typeof window !== 'undefined' ? 
      (window as any).__HERA_JWT__ : ''
    const fieldConfig = await getFieldConfiguration('${config.ENTITY_TYPE}', orgId, token)
    
    // Validate form data
    const formData = {
      ...(input.entity_name && { entity_name: input.entity_name }),
      ...input.dynamic_fields
    }
    const errors = validateFormData(fieldConfig.fields, formData)
    
    if (Object.keys(errors).length > 0) {
      throw new Error(\`Validation failed: \${Object.values(errors).join(', ')}\`)
    }

    // Convert to dynamic fields format
    const dynamicFields = formDataToDynamicFields(fieldConfig.fields, formData)

    // Prepare API v2 command
    const payload = {
      op: "entities" as const,
      p_operation: "UPDATE" as const,
      p_data: {
        entity_id: ${config.entityName}Id,
        entity_type: "${config.ENTITY_TYPE}",
        smart_code: "${config.smartCodeBase}.v1",
        organization_id: orgId,
        ...(input.entity_name && { entity_name: input.entity_name }),
        ...(dynamicFields.length > 0 && { dynamic_fields: dynamicFields })
      }
    }

    const result = await heraCommand(payload, { orgId })

    // Invalidate cache
    await invalidateEntity('${config.entityName}', ${config.entityName}Id)
    await invalidateEntity('${config.entityName}') // Also invalidate list

    return result
  }, [orgId, invalidateEntity])

  const delete${config.EntityName} = useCallback(async (${config.entityName}Id: string) => {
    if (!orgId) {
      throw new Error('No organization context available')
    }

    // Prepare API v2 command
    const payload = {
      op: "entities" as const,
      p_operation: "DELETE" as const,
      p_data: {
        entity_id: ${config.entityName}Id,
        entity_type: "${config.ENTITY_TYPE}",
        smart_code: "${config.smartCodeBase}.v1",
        organization_id: orgId
      }
    }

    const result = await heraCommand(payload, { orgId })

    // Invalidate cache
    await invalidateEntity('${config.entityName}', ${config.entityName}Id)
    await invalidateEntity('${config.entityName}') // Also invalidate list

    return result
  }, [orgId, invalidateEntity])

  return {
    create${config.EntityName},
    update${config.EntityName},
    delete${config.EntityName}
  }
}

/**
 * Hook for ${config.entityName} field configuration
 * Returns org-specific field definitions for forms
 */
export function use${config.EntityName}FieldConfig() {
  const { orgId } = useOrg()
  const [fieldConfig, setFieldConfig] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!orgId) return

    let isCancelled = false
    setIsLoading(true)
    setError(null)

    const loadConfig = async () => {
      try {
        const token = typeof window !== 'undefined' ? 
          (window as any).__HERA_JWT__ : ''
        const config = await getFieldConfiguration('${config.ENTITY_TYPE}', orgId, token)
        
        if (!isCancelled) {
          setFieldConfig(config)
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err instanceof Error ? err.message : 'Failed to load field configuration')
        }
      } finally {
        if (!isCancelled) {
          setIsLoading(false)
        }
      }
    }

    loadConfig()

    return () => {
      isCancelled = true
    }
  }, [orgId])

  return { fieldConfig, isLoading, error }
}
`

  return {
    filePath: `src/lib/hooks/use${config.EntityName}s.ts`,
    content
  }
}

// Generate API route
function generateAPIRoute(config) {
  const content = `/**
 * API v2 ${config.EntityName} Read Endpoint
 * 
 * Generated by HERA Hook-Driven Module Generator
 * RLS-scoped ${config.entityName} data access with organization filtering
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { validateActorMembership } from '@/lib/org-context'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function GET(request: NextRequest) {
  try {
    // Extract organization context from header
    const orgId = request.headers.get('X-Organization-Id')
    if (!orgId) {
      return NextResponse.json(
        { 
          error: 'Organization filter required',
          error_code: 'ORG_FILTER_MISSING',
          details: { required_header: 'X-Organization-Id' }
        },
        { status: 400 }
      )
    }

    // Extract JWT token for actor validation
    const authHeader = request.headers.get('Authorization')
    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json(
        { 
          error: 'Authentication required',
          error_code: 'AUTH_MISSING'
        },
        { status: 401 }
      )
    }

    const token = authHeader.substring(7)

    // Validate actor membership
    const isValidMember = await validateActorMembership(token, orgId)
    if (!isValidMember) {
      return NextResponse.json(
        { 
          error: 'Actor not member of organization',
          error_code: 'ACTOR_NOT_MEMBER',
          details: { organization_id: orgId }
        },
        { status: 403 }
      )
    }

    // Parse query parameters
    const url = new URL(request.url)
    const params = {
      search: url.searchParams.get('search') || '',
      limit: Math.min(Number(url.searchParams.get('limit')) || 50, 100),
      offset: Number(url.searchParams.get('offset')) || 0,
      sort: url.searchParams.get('sort') || 'entity_name',
      order: (url.searchParams.get('order') as 'asc' | 'desc') || 'asc'
    }

    // Build query with RLS enforcement
    let query = supabase
      .from('core_entities')
      .select(\`
        id,
        entity_name,
        entity_type,
        smart_code,
        created_at,
        updated_at,
        created_by,
        updated_by,
        organization_id
      \`)
      .eq('entity_type', '${config.ENTITY_TYPE}')
      .eq('organization_id', orgId) // RLS enforcement

    // Apply search filter
    if (params.search) {
      query = query.ilike('entity_name', \`%\${params.search}%\`)
    }

    // Apply sorting and pagination
    query = query
      .order(params.sort!, { ascending: params.order === 'asc' })
      .range(params.offset!, params.offset! + params.limit! - 1)

    const { data: entities, error: entitiesError } = await query

    if (entitiesError) {
      console.error('${config.EntityName} query error:', entitiesError)
      return NextResponse.json(
        { 
          error: 'Database query failed',
          error_code: 'DB_QUERY_ERROR',
          details: entitiesError.message
        },
        { status: 500 }
      )
    }

    // Fetch dynamic fields for each ${config.entityName}
    const entityIds = entities?.map(e => e.id) || []
    let dynamicFieldsMap: Record<string, any[]> = {}

    if (entityIds.length > 0) {
      const { data: dynamicFields, error: dynamicError } = await supabase
        .from('core_dynamic_data')
        .select('*')
        .in('entity_id', entityIds)
        .eq('organization_id', orgId) // RLS enforcement

      if (dynamicError) {
        console.error('Dynamic fields query error:', dynamicError)
        return NextResponse.json(
          { 
            error: 'Dynamic fields query failed',
            error_code: 'DYNAMIC_FIELDS_ERROR',
            details: dynamicError.message
          },
          { status: 500 }
        )
      }

      // Group dynamic fields by entity_id
      dynamicFieldsMap = (dynamicFields || []).reduce((acc, field) => {
        if (!acc[field.entity_id]) {
          acc[field.entity_id] = []
        }
        acc[field.entity_id].push(field)
        return acc
      }, {} as Record<string, any[]>)
    }

    // Transform data with dynamic fields
    const ${config.entityName}s = (entities || []).map(entity => {
      const dynamicFields = dynamicFieldsMap[entity.id] || []
      const dynamicFieldsObject = dynamicFields.reduce((acc, field) => {
        acc[field.field_name] = {
          field_value_text: field.field_value_text,
          field_value_number: field.field_value_number,
          field_value_boolean: field.field_value_boolean,
          field_value_json: field.field_value_json,
          smart_code: field.smart_code
        }
        return acc
      }, {} as Record<string, any>)

      return {
        entity_id: entity.id,
        entity_name: entity.entity_name,
        entity_type: entity.entity_type,
        smart_code: entity.smart_code,
        created_at: entity.created_at,
        updated_at: entity.updated_at,
        created_by: entity.created_by,
        updated_by: entity.updated_by,
        dynamic_fields: dynamicFieldsObject
      }
    })

    // Get total count for pagination
    const { count: totalCount } = await supabase
      .from('core_entities')
      .select('*', { count: 'exact', head: true })
      .eq('entity_type', '${config.ENTITY_TYPE}')
      .eq('organization_id', orgId)
      .ilike('entity_name', params.search ? \`%\${params.search}%\` : '%')

    const response = {
      data: ${config.entityName}s,
      pagination: {
        limit: params.limit,
        offset: params.offset,
        total: totalCount || 0,
        has_more: (params.offset! + params.limit!) < (totalCount || 0)
      },
      organization_id: orgId,
      timestamp: new Date().toISOString()
    }

    return NextResponse.json(response)

  } catch (error) {
    console.error('${config.EntityName} API error:', error)
    return NextResponse.json(
      { 
        error: 'Internal server error',
        error_code: 'INTERNAL_ERROR',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}
`

  return {
    filePath: `src/app/api/v2/${config.entityName}/route.ts`,
    content
  }
}

// Generate API route by ID
function generateAPIRouteById(config) {
  const content = `/**
 * API v2 ${config.EntityName} by ID Endpoint
 * 
 * Generated by HERA Hook-Driven Module Generator  
 * RLS-scoped single ${config.entityName} access with organization filtering
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { validateActorMembership } from '@/lib/org-context'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const ${config.entityName}Id = params.id

    // Extract organization context
    const orgId = request.headers.get('X-Organization-Id')
    if (!orgId) {
      return NextResponse.json(
        { 
          error: 'Organization filter required',
          error_code: 'ORG_FILTER_MISSING'
        },
        { status: 400 }
      )
    }

    // Extract and validate JWT token
    const authHeader = request.headers.get('Authorization')
    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json(
        { 
          error: 'Authentication required',
          error_code: 'AUTH_MISSING'
        },
        { status: 401 }
      )
    }

    const token = authHeader.substring(7)

    // Validate actor membership
    const isValidMember = await validateActorMembership(token, orgId)
    if (!isValidMember) {
      return NextResponse.json(
        { 
          error: 'Actor not member of organization',
          error_code: 'ACTOR_NOT_MEMBER'
        },
        { status: 403 }
      )
    }

    // Fetch entity with RLS enforcement
    const { data: entity, error: entityError } = await supabase
      .from('core_entities')
      .select('*')
      .eq('id', ${config.entityName}Id)
      .eq('entity_type', '${config.ENTITY_TYPE}')
      .eq('organization_id', orgId) // RLS enforcement
      .single()

    if (entityError || !entity) {
      return NextResponse.json(
        { 
          error: '${config.EntityName} not found',
          error_code: '${config.ENTITY_TYPE}_NOT_FOUND',
          details: { ${config.entityName}_id: ${config.entityName}Id, organization_id: orgId }
        },
        { status: 404 }
      )
    }

    // Fetch dynamic fields and relationships
    const [dynamicFieldsResult, relationshipsResult] = await Promise.all([
      supabase
        .from('core_dynamic_data')
        .select('*')
        .eq('entity_id', ${config.entityName}Id)
        .eq('organization_id', orgId),
      supabase
        .from('core_relationships')
        .select(\`
          relationship_type,
          target_entity_id,
          target_entities:target_entity_id(entity_name)
        \`)
        .eq('source_entity_id', ${config.entityName}Id)
        .eq('organization_id', orgId)
    ])

    // Transform dynamic fields
    const dynamicFieldsObject = (dynamicFieldsResult.data || []).reduce((acc, field) => {
      acc[field.field_name] = {
        field_value_text: field.field_value_text,
        field_value_number: field.field_value_number,
        field_value_boolean: field.field_value_boolean,
        field_value_json: field.field_value_json,
        smart_code: field.smart_code
      }
      return acc
    }, {} as Record<string, any>)

    // Transform relationships
    const relationshipsArray = (relationshipsResult.data || []).map(rel => ({
      relationship_type: rel.relationship_type,
      target_entity_id: rel.target_entity_id,
      target_entity_name: (rel.target_entities as any)?.entity_name || 'Unknown'
    }))

    const ${config.entityName} = {
      entity_id: entity.id,
      entity_name: entity.entity_name,
      entity_type: entity.entity_type,
      smart_code: entity.smart_code,
      created_at: entity.created_at,
      updated_at: entity.updated_at,
      created_by: entity.created_by,
      updated_by: entity.updated_by,
      dynamic_fields: dynamicFieldsObject,
      relationships: relationshipsArray
    }

    return NextResponse.json({
      data: ${config.entityName},
      organization_id: orgId,
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('${config.EntityName} by ID API error:', error)
    return NextResponse.json(
      { 
        error: 'Internal server error',
        error_code: 'INTERNAL_ERROR'
      },
      { status: 500 }
    )
  }
}
`

  return {
    filePath: `src/app/api/v2/${config.entityName}/[id]/route.ts`,
    content
  }
}

// Generate page component using Fiori++ templates
function generatePage(config) {
  const content = `/**
 * ${config.EntityName} List Report
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Uses Fiori++ List Report template with glassmorphism design
 */

'use client'

import React from 'react'
import { useState } from 'react'
import { ColumnDef } from '@tanstack/react-table'
import { use${config.EntityName}s, use${config.EntityName}Mutations } from '@/lib/hooks/use${config.EntityName}s'
import { useHERAAuth } from '@/components/auth/HERAAuthProvider'
import HERAMasterDataTemplate from '@/components/hera/HERAMasterDataTemplate'
import { HERAListReport, QuickFilters } from '@/components/ui-kit/floorplans/list-report'
import { StatusBadge } from '@/components/ui-kit/primitives'
import { Button } from '@/components/ui/button'
import { ${config.icon}, Plus, Mail, Search } from 'lucide-react'

// Type definitions
interface ${config.EntityName} {
  entity_id: string
  entity_name: string
  entity_type: '${config.ENTITY_TYPE}'
  smart_code: string
  created_at: string
  updated_at: string
  created_by: string
  updated_by: string
  dynamic_fields?: Record<string, {
    field_value_text?: string
    field_value_number?: number
    field_value_boolean?: boolean
    field_value_json?: any
    smart_code: string
  }>
}

// Column definitions for ${config.EntityName} data grid
const ${config.entityName}Columns: ColumnDef<${config.EntityName}>[] = [
  {
    accessorKey: 'entity_name',
    header: '${config.EntityName} Name',
    cell: ({ row }) => (
      <div className="flex items-center gap-3">
        <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-blue-500 to-blue-600 flex items-center justify-center">
          <${config.icon} className="w-4 h-4 text-white" />
        </div>
        <div>
          <div className="font-medium">{row.original.entity_name}</div>
          <div className="text-xs text-gray-500">{row.original.entity_id}</div>
        </div>
      </div>
    )
  },
  {
    accessorKey: 'smart_code',
    header: 'Smart Code',
    cell: ({ row }) => (
      <code className="text-xs bg-gray-100/80 dark:bg-gray-800/80 px-2 py-1 rounded backdrop-blur-sm">
        {row.original.smart_code}
      </code>
    )
  },
  {
    accessorKey: 'created_at',
    header: 'Created',
    cell: ({ row }) => (
      <div className="text-sm">
        {new Date(row.original.created_at).toLocaleDateString()}
      </div>
    )
  },
  {
    accessorKey: 'updated_at', 
    header: 'Last Updated',
    cell: ({ row }) => (
      <div className="text-sm">
        {new Date(row.original.updated_at).toLocaleDateString()}
      </div>
    )
  }
]

// Master data form configuration for create/edit
const ${config.ENTITY_TYPE}_SECTIONS = [
  {
    id: 'basic',
    label: 'Basic Information',
    icon: ${config.icon},
    required: true,
    description: 'Enter basic ${config.entityName} information and categorization'
  },
  {
    id: 'contact',
    label: 'Contact Details', 
    icon: Mail,
    required: false,
    description: 'Contact information and communication preferences'
  },
  {
    id: 'business',
    label: 'Business Data',
    icon: Search,
    required: false,
    description: 'Business-specific fields and classifications'
  }
]

const ${config.ENTITY_TYPE}_FIELDS = [
  {
    id: 'entity_name',
    label: '${config.EntityName} Name',
    type: 'text' as const,
    required: true,
    placeholder: 'Enter ${config.entityName} name',
    section: 'basic',
    validation: (value: string) => {
      return !value.trim() ? 'Name is required' : null
    }
  },
  {
    id: 'entity_code',
    label: '${config.EntityName} Code',
    type: 'text' as const,
    required: true,
    placeholder: 'Auto-generated from name',
    section: 'basic'
  },
  {
    id: 'email',
    label: 'Email Address',
    type: 'email' as const,
    required: false,
    placeholder: 'contact@example.com',
    section: 'contact',
    validation: (value: string) => {
      if (!value) return null
      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/
      return !emailRegex.test(value) ? 'Please enter a valid email address' : null
    }
  },
  {
    id: 'phone',
    label: 'Phone Number',
    type: 'phone' as const,
    required: false,
    placeholder: '+1 (555) 123-4567',
    section: 'contact'
  }
]

export default function ${config.EntityName}Page() {
  const [showCreateForm, setShowCreateForm] = useState(false)
  const [searchValue, setSearchValue] = useState('')
  const [statusFilter, setStatusFilter] = useState('all')

  // Handle create form submission using HERAMasterDataTemplate
  const handleCreate${config.EntityName} = async (formData: Record<string, any>) => {
    // Generate HERA DNA smart code
    const smartCode = \`${config.smartCodeBase}.\${formData.entity_code || 'ENTITY'}.v1\`
    
    // Prepare dynamic fields from form data
    const dynamicFields = []
    
    if (formData.email) {
      dynamicFields.push({
        field_name: 'email',
        field_type: 'email',
        field_value_text: formData.email,
        smart_code: \`${config.smartCodeBase}.DYN.EMAIL.v1\`
      })
    }
    
    if (formData.phone) {
      dynamicFields.push({
        field_name: 'phone',
        field_type: 'phone',
        field_value_text: formData.phone,
        smart_code: \`${config.smartCodeBase}.DYN.PHONE.v1\`
      })
    }

    // This will be wired to HERA hooks when ready
    console.log('Creating ${config.entityName}:', { smartCode, formData, dynamicFields })
    
    setShowCreateForm(false)
  }

  // Show create form using HERAMasterDataTemplate
  if (showCreateForm) {
    return (
      <HERAMasterDataTemplate
        entityType="${config.entityName}"
        entityLabel="${config.EntityName}"
        sections={${config.ENTITY_TYPE}_SECTIONS}
        fields={${config.ENTITY_TYPE}_FIELDS}
        backUrl="${config.route}"
        onSubmit={handleCreate${config.EntityName}}
      />
    )
  }

  // Use Fiori++ List Report template
  return (
    <HERAListReport
      title="${config.EntityName}s"
      entityType="${config.EntityName}"
      useListHook={use${config.EntityName}s}
      useMutationsHook={use${config.EntityName}Mutations}
      onCreateNew={() => setShowCreateForm(true)}
      customColumns={${config.entityName}Columns}
      searchValue={searchValue}
      onSearchChange={setSearchValue}
      filters={
        <QuickFilters
          statusOptions={[
            { value: 'active', label: 'Active' },
            { value: 'inactive', label: 'Inactive' },
            { value: 'pending', label: 'Pending' }
          ]}
          onStatusChange={setStatusFilter}
        />
      }
      onView={(${config.entityName}) => {
        console.log('View ${config.entityName}:', ${config.entityName})
        // Navigate to object page when implemented
      }}
      onEdit={(${config.entityName}) => {
        console.log('Edit ${config.entityName}:', ${config.entityName})
        // Open edit form when implemented
      }}
      emptyState={{
        icon: <${config.icon} className="w-8 h-8 text-gray-400" />,
        title: \`No ${config.entityName}s found\`,
        description: \`Get started by creating your first ${config.entityName}.\`,
        action: (
          <Button onClick={() => setShowCreateForm(true)}>
            <Plus className="w-4 h-4 mr-2" />
            Create ${config.EntityName}
          </Button>
        )
      }}
      showSelection={true}
      showExport={true}
      showFilters={true}
    />
  )
}
`

  return {
    filePath: `src/app/${config.route}/page.tsx`,
    content
  }
}

// Generate guardrails tests
function generateGuardrailsTests(config) {
  const content = `/**
 * ${config.EntityName} Guardrails Tests
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Tests API v2 guardrails validation for ${config.entityName}
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { heraCommand } from '@/lib/hera/client'

describe('${config.EntityName} Guardrails Validation', () => {
  let testOrgId: string
  let testToken: string

  beforeAll(async () => {
    // TODO: Set up test environment
    testOrgId = process.env.TEST_ORGANIZATION_ID!
    testToken = process.env.TEST_JWT_TOKEN!
  })

  it('should require Smart Code for entity creation', async () => {
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: "Test ${config.EntityName}",
        // Missing smart_code
        organization_id: testOrgId
      }
    }

    await expect(heraCommand(payload, { orgId: testOrgId, token: testToken }))
      .rejects.toThrow(/smart.*code/i)
  })

  it('should validate Smart Code format', async () => {
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: "Test ${config.EntityName}",
        smart_code: "invalid.format", // Invalid Smart Code
        organization_id: testOrgId
      }
    }

    await expect(heraCommand(payload, { orgId: testOrgId, token: testToken }))
      .rejects.toThrow(/SMARTCODE_INVALID_FORMAT/)
  })

  it('should require organization filter', async () => {
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: "Test ${config.EntityName}",
        smart_code: "${config.smartCodeBase}.v1"
        // Missing organization_id
      }
    }

    await expect(heraCommand(payload, { token: testToken }))
      .rejects.toThrow(/ORG_FILTER_MISSING/)
  })

  it('should validate organization membership', async () => {
    const invalidOrgId = "00000000-0000-0000-0000-000000000000"
    
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: "Test ${config.EntityName}",
        smart_code: "${config.smartCodeBase}.v1",
        organization_id: invalidOrgId
      }
    }

    await expect(heraCommand(payload, { orgId: invalidOrgId, token: testToken }))
      .rejects.toThrow(/ACTOR_NOT_MEMBER/)
  })

  it('should accept valid Smart Code patterns', async () => {
    const validPayload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: "Valid Test ${config.EntityName}",
        smart_code: "${config.smartCodeBase}.v1",
        organization_id: testOrgId,
        dynamic_fields: [
          {
            field_name: "test_field",
            field_type: "text",
            field_value_text: "Test Value",
            smart_code: "${config.smartCodeBase}.DYN.TEST_FIELD.v1"
          }
        ]
      }
    }

    const result = await heraCommand(validPayload, { orgId: testOrgId, token: testToken })
    expect(result).toBeDefined()
    expect(result.data).toBeDefined()
  })

  it('should validate dynamic field Smart Codes', async () => {
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "${config.ENTITY_TYPE}",
        entity_name: "Test ${config.EntityName}",
        smart_code: "${config.smartCodeBase}.v1",
        organization_id: testOrgId,
        dynamic_fields: [
          {
            field_name: "test_field",
            field_type: "text",
            field_value_text: "Test Value"
            // Missing smart_code on dynamic field
          }
        ]
      }
    }

    await expect(heraCommand(payload, { orgId: testOrgId, token: testToken }))
      .rejects.toThrow(/SMARTCODE_MISSING_FIELD/)
  })
})
`

  return {
    filePath: `tests/api/guardrails-${config.entityName}.spec.ts`,
    content
  }
}

// Generate RLS tests
function generateRLSTests(config) {
  const content = `/**
 * ${config.EntityName} RLS Tests
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Tests row-level security isolation for ${config.entityName}
 */

import { describe, it, expect, beforeAll } from 'vitest'

describe('${config.EntityName} RLS Isolation', () => {
  let orgAId: string
  let orgBId: string
  let tokenA: string
  let tokenB: string

  beforeAll(async () => {
    // TODO: Set up test environment with two orgs
    orgAId = process.env.TEST_ORG_A_ID!
    orgBId = process.env.TEST_ORG_B_ID!
    tokenA = process.env.TEST_ORG_A_TOKEN!
    tokenB = process.env.TEST_ORG_B_TOKEN!
  })

  it('should prevent cross-org read access', async () => {
    // Create ${config.entityName} in Org A
    const response = await fetch('/api/v2/${config.entityName}', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${tokenA}\`,
        'X-Organization-Id': orgAId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        entity_name: 'Org A ${config.EntityName}',
        smart_code: '${config.smartCodeBase}.v1'
      })
    })

    expect(response.status).toBe(201)
    const { data: orgA${config.EntityName} } = await response.json()

    // Try to read Org A ${config.entityName} from Org B context
    const crossOrgResponse = await fetch(\`/api/v2/${config.entityName}/\${orgA${config.EntityName}.entity_id}\`, {
      headers: {
        'Authorization': \`Bearer \${tokenB}\`,
        'X-Organization-Id': orgBId
      }
    })

    expect(crossOrgResponse.status).toBe(404) // Should not find due to RLS
  })

  it('should prevent cross-org write access', async () => {
    // Try to update non-existent ${config.entityName} from different org
    const crossOrgUpdateResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${tokenB}\`,
        'X-Organization-Id': orgBId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "UPDATE",
        p_data: {
          entity_id: "non-existent-id",
          entity_type: "${config.ENTITY_TYPE}",
          entity_name: "Hacked ${config.EntityName}",
          smart_code: "${config.smartCodeBase}.v1",
          organization_id: orgAId // Trying to write to different org
        }
      })
    })

    expect(crossOrgUpdateResponse.status).toBe(403) // Should be forbidden
  })

  it('should allow same-org access', async () => {
    // Create ${config.entityName} in Org A
    const createResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${tokenA}\`,
        'X-Organization-Id': orgAId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "CREATE",
        p_data: {
          entity_type: "${config.ENTITY_TYPE}",
          entity_name: "Same Org ${config.EntityName}",
          smart_code: "${config.smartCodeBase}.v1",
          organization_id: orgAId
        }
      })
    })

    expect(createResponse.status).toBe(200)
    const { data: created${config.EntityName} } = await createResponse.json()

    // Read same ${config.entityName} from same org
    const readResponse = await fetch(\`/api/v2/${config.entityName}/\${created${config.EntityName}.entity_id}\`, {
      headers: {
        'Authorization': \`Bearer \${tokenA}\`,
        'X-Organization-Id': orgAId
      }
    })

    expect(readResponse.status).toBe(200)
    const { data: read${config.EntityName} } = await readResponse.json()
    expect(read${config.EntityName}.entity_id).toBe(created${config.EntityName}.entity_id)
  })

  it('should isolate ${config.entityName} lists by organization', async () => {
    // Get ${config.entityName} list for Org A
    const listAResponse = await fetch('/api/v2/${config.entityName}', {
      headers: {
        'Authorization': \`Bearer \${tokenA}\`,
        'X-Organization-Id': orgAId
      }
    })

    expect(listAResponse.status).toBe(200)
    const { data: orgA${config.EntityName}s } = await listAResponse.json()

    // Get ${config.entityName} list for Org B  
    const listBResponse = await fetch('/api/v2/${config.entityName}', {
      headers: {
        'Authorization': \`Bearer \${tokenB}\`,
        'X-Organization-Id': orgBId
      }
    })

    expect(listBResponse.status).toBe(200)
    const { data: orgB${config.EntityName}s } = await listBResponse.json()

    // Verify no overlap between org lists
    const orgAIds = orgA${config.EntityName}s.map(c => c.entity_id)
    const orgBIds = orgB${config.EntityName}s.map(c => c.entity_id)
    const overlap = orgAIds.filter(id => orgBIds.includes(id))
    
    expect(overlap).toHaveLength(0)
  })
})
`

  return {
    filePath: `tests/tenant/rls-${config.entityName}.spec.ts`,
    content
  }
}

// Generate actor stamping tests
function generateActorTests(config) {
  const content = `/**
 * ${config.EntityName} Actor Stamping Tests
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Tests actor stamping coverage for ${config.entityName}
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { createClient } from '@supabase/supabase-js'

describe('${config.EntityName} Actor Stamping', () => {
  let supabase: any
  let testOrgId: string

  beforeAll(async () => {
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )
    testOrgId = process.env.TEST_ORGANIZATION_ID!
  })

  it('should stamp created_by and updated_by on entity creation', async () => {
    // Create test ${config.entityName} via API v2 command
    const createResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.TEST_JWT_TOKEN}\`,
        'X-Organization-Id': testOrgId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "CREATE",
        p_data: {
          entity_type: "${config.ENTITY_TYPE}",
          entity_name: "Actor Test ${config.EntityName}",
          smart_code: "${config.smartCodeBase}.v1",
          organization_id: testOrgId
        }
      })
    })

    expect(createResponse.status).toBe(200)
    const { data: created${config.EntityName} } = await createResponse.json()

    // Verify actor stamps in database
    const { data: entity } = await supabase
      .from('core_entities')
      .select('created_by, updated_by, created_at, updated_at')
      .eq('id', created${config.EntityName}.entity_id)
      .single()

    expect(entity.created_by).toBeDefined()
    expect(entity.updated_by).toBeDefined()
    expect(entity.created_at).toBeDefined()
    expect(entity.updated_at).toBeDefined()
    expect(entity.created_by).toBe(entity.updated_by) // Same actor for creation
  })

  it('should update updated_by on entity modification', async () => {
    // Create test ${config.entityName}
    const createResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.TEST_JWT_TOKEN}\`,
        'X-Organization-Id': testOrgId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "CREATE",
        p_data: {
          entity_type: "${config.ENTITY_TYPE}",
          entity_name: "Update Test ${config.EntityName}",
          smart_code: "${config.smartCodeBase}.v1",
          organization_id: testOrgId
        }
      })
    })

    const { data: created${config.EntityName} } = await createResponse.json()
    const originalCreatedBy = created${config.EntityName}.created_by

    // Update the ${config.entityName}
    const updateResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.TEST_JWT_TOKEN}\`,
        'X-Organization-Id': testOrgId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "UPDATE",
        p_data: {
          entity_id: created${config.EntityName}.entity_id,
          entity_type: "${config.ENTITY_TYPE}",
          entity_name: "Updated Test ${config.EntityName}",
          smart_code: "${config.smartCodeBase}.v1",
          organization_id: testOrgId
        }
      })
    })

    expect(updateResponse.status).toBe(200)

    // Verify updated_by is stamped
    const { data: updatedEntity } = await supabase
      .from('core_entities')
      .select('created_by, updated_by, created_at, updated_at')
      .eq('id', created${config.EntityName}.entity_id)
      .single()

    expect(updatedEntity.created_by).toBe(originalCreatedBy) // Should not change
    expect(updatedEntity.updated_by).toBeDefined()
    expect(new Date(updatedEntity.updated_at)).toBeGreaterThan(new Date(updatedEntity.created_at))
  })

  it('should maintain ‚â•95% actor coverage across Sacred Six tables', async () => {
    // Check coverage in core_entities
    const { data: entities, count: totalEntities } = await supabase
      .from('core_entities')
      .select('created_by', { count: 'exact' })
      .eq('entity_type', '${config.ENTITY_TYPE}')
      .eq('organization_id', testOrgId)

    const entitiesWithActors = entities?.filter(e => e.created_by !== null).length || 0
    const entityCoverage = totalEntities ? (entitiesWithActors / totalEntities) * 100 : 0

    expect(entityCoverage).toBeGreaterThanOrEqual(95)

    // Check coverage in core_dynamic_data
    const { data: dynamicData, count: totalDynamic } = await supabase
      .from('core_dynamic_data')
      .select('created_by, entity_id', { count: 'exact' })
      .eq('organization_id', testOrgId)
      .in('entity_id', entities?.map(e => e.id) || [])

    const dynamicWithActors = dynamicData?.filter(d => d.created_by !== null).length || 0
    const dynamicCoverage = totalDynamic ? (dynamicWithActors / totalDynamic) * 100 : 0

    expect(dynamicCoverage).toBeGreaterThanOrEqual(95)

    console.log(\`${config.EntityName} Actor Coverage:
      - Entities: \${entityCoverage.toFixed(1)}% (\${entitiesWithActors}/\${totalEntities})
      - Dynamic Data: \${dynamicCoverage.toFixed(1)}% (\${dynamicWithActors}/\${totalDynamic})\`)
  })

  it('should prevent actor-less writes', async () => {
    // This test ensures the RPC functions reject writes without actor context
    // In practice, this should be caught by the API v2 gateway before reaching RPC
    
    const { error } = await supabase.rpc('hera_entities_crud_v1', {
      p_action: 'CREATE',
      // p_actor_user_id missing
      p_organization_id: testOrgId,
      p_entity: {
        entity_type: '${config.ENTITY_TYPE}',
        entity_name: 'No Actor ${config.EntityName}',
        smart_code: '${config.smartCodeBase}.v1'
      },
      p_dynamic: {},
      p_relationships: [],
      p_options: {}
    })

    expect(error).toBeDefined()
    expect(error.message).toMatch(/actor/i)
  })
})
`

  return {
    filePath: `tests/tenant/actor-${config.entityName}.spec.ts`,
    content
  }
}

// Update package.json scripts
function updatePackageScripts(config) {
  const packagePath = 'package.json'
  if (!fs.existsSync(packagePath)) return

  try {
    const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'))
    
    if (!packageData.scripts) {
      packageData.scripts = {}
    }

    // Add entity-specific test scripts
    packageData.scripts[`test:${config.entityName}`] = `vitest run tests/**/*${config.entityName}*`
    packageData.scripts[`test:${config.entityName}:watch`] = `vitest watch tests/**/*${config.entityName}*`
    packageData.scripts[`test:${config.entityName}:rls`] = `vitest run tests/tenant/rls-${config.entityName}.spec.ts`
    packageData.scripts[`test:${config.entityName}:actor`] = `vitest run tests/tenant/actor-${config.entityName}.spec.ts`
    packageData.scripts[`test:${config.entityName}:guardrails`] = `vitest run tests/api/guardrails-${config.entityName}.spec.ts`

    fs.writeFileSync(packagePath, JSON.stringify(packageData, null, 2))
    console.log(`‚úÖ Updated package.json with ${config.entityName} test scripts`)
  } catch (error) {
    console.warn(`‚ö†Ô∏è Failed to update package.json:`, error.message)
  }
}

// Utility functions
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}

// CLI interface
if (require.main === module) {
  const [entityName, module] = process.argv.slice(2)
  
  if (!entityName) {
    console.log(`üöÄ HERA Hook-Driven Module Generator
    
Usage: npm run generate:module <entity> [module]

Available entities: ${Object.keys(ENTITY_PRESETS).join(', ')}

Examples:
  npm run generate:module customers retail
  npm run generate:module accounts crm
  npm run generate:module products retail
  npm run generate:module contacts crm
  npm run generate:module leads crm

This generates a complete "one-go build" module with:
‚úÖ Entity-specific hooks (useEntitys, useEntity, useEntityMutations)
‚úÖ API v2 read routes with RLS guards
‚úÖ Shared org-aware page with dynamic fields
‚úÖ Guardrails, RLS, and actor stamping tests
‚úÖ Smart Code validation built-in
‚úÖ Organization context automatic
`)
    process.exit(1)
  }

  generateModule(entityName, module)
}

module.exports = { generateModule, ENTITY_PRESETS }
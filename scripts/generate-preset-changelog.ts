#!/usr/bin/env ts-node

/**
 * Generates a human-readable changelog by diffing live presets vs snapshots.
 * - Writes docs/presets/CHANGELOG.md
 * - Prints path to file for CI to pick up
 * - Optional --since=<baseSHA> to scope to PR range (defaults to HEAD~1)
 */

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { execSync } from 'child_process';

// ---- Helpers ---------------------------------------------------------------

const SNAP_DIR = 'snapshots/presets';
const DOCS_FILE = 'docs/presets/CHANGELOG.md';
const PRESET_REGISTRY = 'src/hooks/entityPresets.ts'; // used only for link hints

type AnyObj = Record<string, unknown>;
const readJson = (p: string) => JSON.parse(fs.readFileSync(p, 'utf8'));

const safe = (v: unknown) => JSON.stringify(v, null, 2);
const hash = (v: unknown) => crypto.createHash('sha1').update(safe(v)).digest('hex').slice(0, 8);

const listFiles = (dir: string, ext = '.json') =>
  fs.existsSync(dir) ? fs.readdirSync(dir).filter(f => f.endsWith(ext)) : [];

// Deep diff focused on *what reviewers care about*.
function diffObjects(a: AnyObj, b: AnyObj, pathPrefix = ''): string[] {
  const lines: string[] = [];
  const keys = Array.from(new Set([...Object.keys(a ?? {}), ...Object.keys(b ?? {})])).sort();

  for (const k of keys) {
    const p = pathPrefix ? `${pathPrefix}.${k}` : k;
    const av = (a ?? {})[k];
    const bv = (b ?? {})[k];

    if (av === undefined && bv !== undefined) {
      lines.push(`➕ **Added** \`${p}\`: ${safe(bv)}`);
      continue;
    }
    if (av !== undefined && bv === undefined) {
      lines.push(`➖ **Removed** \`${p}\`: ${safe(av)}`);
      continue;
    }

    const bothObjects =
      typeof av === 'object' && av !== null && typeof bv === 'object' && bv !== null;

    if (!bothObjects) {
      if (safe(av) !== safe(bv)) {
        lines.push(`✏️ **Changed** \`${p}\`:\n- was: ${safe(av)}\n- now: ${safe(bv)}`);
      }
      continue;
    }

    // Arrays: show added/removed items by id-ish props or raw
    if (Array.isArray(av) && Array.isArray(bv)) {
      const aH = hash(av);
      const bH = hash(bv);
      if (aH !== bH) {
        // Try treat arrays of objects with a `name` or `type` as identity
        const key = ['name', 'type', 'field', 'smart_code', 'relationship_type'].find(k => {
          return av.every(x => typeof x === 'object' && x && k in (x as AnyObj)) &&
                 bv.every(x => typeof x === 'object' && x && k in (x as AnyObj));
        });

        if (key) {
          const aMap = new Map((av as AnyObj[]).map(o => [String(o[key as string]), o]));
          const bMap = new Map((bv as AnyObj[]).map(o => [String(o[key as string]), o]));
          const names = new Set([...aMap.keys(), ...bMap.keys()]);
          for (const n of names) {
            if (!aMap.has(n)) lines.push(`➕ **Added** \`${p}[${n}]\`: ${safe(bMap.get(n))}`);
            else if (!bMap.has(n)) lines.push(`➖ **Removed** \`${p}[${n}]\`: ${safe(aMap.get(n))}`);
            else {
              const inner = diffObjects(aMap.get(n) as AnyObj, bMap.get(n) as AnyObj, `${p}[${n}]`);
              lines.push(...inner);
            }
          }
        } else {
          lines.push(`✏️ **Changed** \`${p}\` (array):\n- was: ${safe(av)}\n- now: ${safe(bv)}`);
        }
      }
      continue;
    }

    // Recurse objects
    lines.push(...diffObjects(av as AnyObj, bv as AnyObj, p));
  }
  return lines;
}

// ---- Main ------------------------------------------------------------------

function main() {
  const files = listFiles(SNAP_DIR);
  if (files.length === 0) {
    console.error(`No snapshots found in ${SNAP_DIR}. Run npm run presets:snapshot first.`);
    process.exit(2);
  }

  const sections: string[] = [];
  sections.push(`# Preset Changelog\n`);
  sections.push(
    `> This changelog is auto-generated by diffing live presets with snapshots. ` +
      `Update snapshots with \`npm run presets:snapshot\` when changes are intentional.\n`
  );

  for (const f of files) {
    const snapshotPath = path.join(SNAP_DIR, f);
    const currentPath = path.join('snapshots/current', f); // produced in CI beforehand

    if (!fs.existsSync(currentPath)) {
      sections.push(`## ${f.replace('.json', '')}\n- ⚠️ No current build to compare.\n`);
      continue;
    }

    const snap = readJson(snapshotPath);
    const cur = readJson(currentPath);

    const changes = diffObjects(snap, cur);
    const title = f.replace('.json', '');

    sections.push(`## ${title}`);
    if (changes.length === 0) {
      sections.push(`- ✅ No changes.`);
    } else {
      sections.push(...changes.map(l => `- ${l}`));
    }
    sections.push(''); // spacer
  }

  // Write file
  fs.mkdirSync(path.dirname(DOCS_FILE), { recursive: true });
  fs.writeFileSync(DOCS_FILE, sections.join('\n'), 'utf8');

  // Print file path for the workflow step
  console.log(DOCS_FILE);
}

main();
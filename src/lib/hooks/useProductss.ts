/**
 * Products Entity Hooks
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Provides complete CRUD operations with:
 * - RLS-scoped reads via API routes
 * - API v2 command writes with actor stamping  
 * - Smart Code validation built-in
 * - Automatic cache invalidation on mutations
 */

'use client'

import { useCallback, useState, useEffect } from 'react'
import { useHeraEntityListQuery, useHeraEntityQuery, useHeraCacheControl, useHeraQuery } from './useHeraQuery'
import { heraCommand } from '@/lib/hera/client'
import { useOrg } from './useOrg'
import { getFieldConfiguration, validateFormData, formDataToDynamicFields } from '@/lib/field-config'

export interface Products {
  entity_id: string
  entity_name: string
  entity_type: 'PRODUCT'
  smart_code: string
  created_at: string
  updated_at: string
  created_by: string
  updated_by: string
  dynamic_fields: Record<string, {
    field_value_text?: string
    field_value_number?: number
    field_value_boolean?: boolean
    field_value_json?: any
    smart_code: string
  }>
  relationships?: Array<{
    relationship_type: string
    target_entity_id: string
    target_entity_name: string
  }>
}

export interface ProductsListParams {
  search?: string
  limit?: number
  offset?: number
  sort?: string
  order?: 'asc' | 'desc'
}

export interface CreateProductsInput {
  entity_name: string
  dynamic_fields?: Record<string, any>
}

export interface UpdateProductsInput {
  entity_name?: string
  dynamic_fields?: Record<string, any>
}

/**
 * Hook for listing products with search and pagination
 * Uses RLS-scoped API endpoint for secure data access
 */
export function useProductss(params: ProductsListParams = {}) {
  return useHeraEntityListQuery<Products>(
    'products',
    {
      search: params.search || '',
      limit: params.limit || 50,
      offset: params.offset || 0,
      sort: params.sort || 'entity_name',
      order: params.order || 'asc'
    },
    {
      requireAuth: true,
      requireOrg: true,
      requireMembership: true,
      revalidateOnFocus: false,
      dedupingInterval: 30000 // Cache for 30 seconds
    }
  )
}

/**
 * Hook for fetching a single products by ID
 * Uses RLS-scoped API endpoint
 */
export function useProducts(productsId?: string) {
  return useHeraEntityQuery<Products>(
    'products',
    productsId,
    {
      requireAuth: true,
      requireOrg: true,
      requireMembership: true,
      revalidateOnFocus: false,
      dedupingInterval: 60000 // Cache for 1 minute
    }
  )
}

/**
 * Hook for products mutation operations (CREATE/UPDATE/DELETE)
 * All operations go through API v2 command interface with actor stamping
 */
export function useProductsMutations() {
  const { orgId } = useOrg()
  const { invalidateEntity } = useHeraCacheControl()

  const createProducts = useCallback(async (input: CreateProductsInput) => {
    if (!orgId) {
      throw new Error('No organization context available')
    }

    // Get field configuration for validation
    const token = typeof window !== 'undefined' ? 
      (window as any).__HERA_JWT__ : ''
    const fieldConfig = await getFieldConfiguration('PRODUCT', orgId, token)
    
    // Validate form data
    const formData = {
      entity_name: input.entity_name,
      ...input.dynamic_fields
    }
    const errors = validateFormData(fieldConfig.fields, formData)
    
    if (Object.keys(errors).length > 0) {
      throw new Error(`Validation failed: ${Object.values(errors).join(', ')}`)
    }

    // Convert to dynamic fields format
    const dynamicFields = formDataToDynamicFields(fieldConfig.fields, formData)

    // Prepare API v2 command
    const payload = {
      op: "entities" as const,
      p_operation: "CREATE" as const,
      p_data: {
        entity_type: "PRODUCT",
        entity_name: input.entity_name,
        smart_code: "HERA.RETAIL.PRODUCT.v1",
        organization_id: orgId,
        dynamic_fields: dynamicFields
      }
    }

    const result = await heraCommand(payload, { orgId })

    // Invalidate cache
    await invalidateEntity('products')

    return result
  }, [orgId, invalidateEntity])

  const updateProducts = useCallback(async (
    productsId: string, 
    input: UpdateProductsInput
  ) => {
    if (!orgId) {
      throw new Error('No organization context available')
    }

    // Get field configuration for validation
    const token = typeof window !== 'undefined' ? 
      (window as any).__HERA_JWT__ : ''
    const fieldConfig = await getFieldConfiguration('PRODUCT', orgId, token)
    
    // Validate form data
    const formData = {
      ...(input.entity_name && { entity_name: input.entity_name }),
      ...input.dynamic_fields
    }
    const errors = validateFormData(fieldConfig.fields, formData)
    
    if (Object.keys(errors).length > 0) {
      throw new Error(`Validation failed: ${Object.values(errors).join(', ')}`)
    }

    // Convert to dynamic fields format
    const dynamicFields = formDataToDynamicFields(fieldConfig.fields, formData)

    // Prepare API v2 command
    const payload = {
      op: "entities" as const,
      p_operation: "UPDATE" as const,
      p_data: {
        entity_id: productsId,
        entity_type: "PRODUCT",
        smart_code: "HERA.RETAIL.PRODUCT.v1",
        organization_id: orgId,
        ...(input.entity_name && { entity_name: input.entity_name }),
        ...(dynamicFields.length > 0 && { dynamic_fields: dynamicFields })
      }
    }

    const result = await heraCommand(payload, { orgId })

    // Invalidate cache
    await invalidateEntity('products', productsId)
    await invalidateEntity('products') // Also invalidate list

    return result
  }, [orgId, invalidateEntity])

  const deleteProducts = useCallback(async (productsId: string) => {
    if (!orgId) {
      throw new Error('No organization context available')
    }

    // Prepare API v2 command
    const payload = {
      op: "entities" as const,
      p_operation: "DELETE" as const,
      p_data: {
        entity_id: productsId,
        entity_type: "PRODUCT",
        smart_code: "HERA.RETAIL.PRODUCT.v1",
        organization_id: orgId
      }
    }

    const result = await heraCommand(payload, { orgId })

    // Invalidate cache
    await invalidateEntity('products', productsId)
    await invalidateEntity('products') // Also invalidate list

    return result
  }, [orgId, invalidateEntity])

  return {
    createProducts,
    updateProducts,
    deleteProducts
  }
}

/**
 * Hook for products field configuration
 * Returns org-specific field definitions for forms
 */
export function useProductsFieldConfig() {
  const { orgId } = useOrg()
  const [fieldConfig, setFieldConfig] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!orgId) return

    let isCancelled = false
    setIsLoading(true)
    setError(null)

    const loadConfig = async () => {
      try {
        const token = typeof window !== 'undefined' ? 
          (window as any).__HERA_JWT__ : ''
        const config = await getFieldConfiguration('PRODUCT', orgId, token)
        
        if (!isCancelled) {
          setFieldConfig(config)
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err instanceof Error ? err.message : 'Failed to load field configuration')
        }
      } finally {
        if (!isCancelled) {
          setIsLoading(false)
        }
      }
    }

    loadConfig()

    return () => {
      isCancelled = true
    }
  }, [orgId])

  return { fieldConfig, isLoading, error }
}

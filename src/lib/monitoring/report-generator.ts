/**
 * HERA Report Generator
 * Generates intelligent error reports for production monitoring
 * Smart Code: HERA.MONITORING.REPORT_GENERATOR.v1
 */

'use client'

import type { ProductionError } from './production-monitor'

interface ReportOptions {
  includeUserContext: boolean
  includePerformanceMetrics: boolean
  includeLogs: boolean
  includeNetworkRequests: boolean
  format: 'comprehensive' | 'summary' | 'technical' | 'business'
  maxLogEntries?: number
}

interface GeneratedReport {
  id: string
  timestamp: string
  title: string
  summary: string
  severity: string
  errors: ProductionError[]
  recommendations: string[]
  technical_details: any
  business_impact: string
  format: 'html' | 'json' | 'markdown' | 'pdf'
  size_bytes: number
}

class ReportGenerator {
  /**
   * Generate comprehensive error report
   */
  async generateReport(
    errors: ProductionError[],
    options: ReportOptions
  ): Promise<string> {
    const reportId = `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    switch (options.format) {
      case 'comprehensive':
        return this.generateComprehensiveReport(errors, options, reportId)
      case 'summary':
        return this.generateSummaryReport(errors, options, reportId)
      case 'technical':
        return this.generateTechnicalReport(errors, options, reportId)
      case 'business':
        return this.generateBusinessReport(errors, options, reportId)
      default:
        return this.generateComprehensiveReport(errors, options, reportId)
    }
  }

  /**
   * Generate comprehensive HTML report
   */
  private generateComprehensiveReport(
    errors: ProductionError[],
    options: ReportOptions,
    reportId: string
  ): string {
    const timestamp = new Date().toISOString()
    const severity = this.calculateOverallSeverity(errors)
    const summary = this.generateSummary(errors)
    const recommendations = this.generateRecommendations(errors)

    return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HERA Production Error Report - ${reportId}</title>
  <style>
    ${this.getReportCSS()}
  </style>
</head>
<body>
  <div class="report-container">
    <!-- Header -->
    <header class="report-header">
      <div class="logo">
        <h1>üèõÔ∏è HERA Production Error Report</h1>
      </div>
      <div class="report-meta">
        <div class="meta-item">
          <span class="label">Report ID:</span>
          <span class="value">${reportId}</span>
        </div>
        <div class="meta-item">
          <span class="label">Generated:</span>
          <span class="value">${new Date(timestamp).toLocaleString()}</span>
        </div>
        <div class="meta-item">
          <span class="label">Severity:</span>
          <span class="value severity-${severity}">${severity.toUpperCase()}</span>
        </div>
        <div class="meta-item">
          <span class="label">Error Count:</span>
          <span class="value">${errors.length}</span>
        </div>
      </div>
    </header>

    <!-- Executive Summary -->
    <section class="section">
      <h2>üìä Executive Summary</h2>
      <div class="summary-card">
        <p>${summary}</p>
        ${this.generateBusinessImpact(errors)}
      </div>
    </section>

    <!-- Error Overview -->
    <section class="section">
      <h2>üö® Error Overview</h2>
      ${this.generateErrorOverview(errors)}
    </section>

    <!-- Detailed Errors -->
    <section class="section">
      <h2>üîç Detailed Error Analysis</h2>
      ${errors.map(error => this.generateErrorDetail(error, options)).join('')}
    </section>

    <!-- Recommendations -->
    <section class="section">
      <h2>üí° Recommendations</h2>
      <div class="recommendations">
        ${recommendations.map(rec => `<div class="recommendation">${rec}</div>`).join('')}
      </div>
    </section>

    ${options.includePerformanceMetrics ? this.generatePerformanceSection(errors) : ''}
    
    <!-- Technical Details -->
    <section class="section">
      <h2>üîß Technical Details</h2>
      ${this.generateTechnicalSection(errors, options)}
    </section>

    <!-- Footer -->
    <footer class="report-footer">
      <p>Generated by HERA Production Monitor at ${new Date(timestamp).toLocaleString()}</p>
      <p>For technical support, contact the HERA development team.</p>
    </footer>
  </div>
</body>
</html>`
  }

  /**
   * Generate summary report (shorter format)
   */
  private generateSummaryReport(
    errors: ProductionError[],
    options: ReportOptions,
    reportId: string
  ): string {
    const severity = this.calculateOverallSeverity(errors)
    const summary = this.generateSummary(errors)
    const timestamp = new Date().toISOString()

    return `
# HERA Production Error Summary

**Report ID:** ${reportId}  
**Generated:** ${new Date(timestamp).toLocaleString()}  
**Severity:** ${severity.toUpperCase()}  
**Error Count:** ${errors.length}

## Summary
${summary}

## Error Breakdown
${this.generateErrorBreakdown(errors)}

## Top Issues
${this.getTopIssues(errors).map(issue => `- ${issue}`).join('\n')}

## Immediate Actions Needed
${this.generateRecommendations(errors).slice(0, 3).map(rec => `- ${rec}`).join('\n')}

---
Generated by HERA Production Monitor
    `.trim()
  }

  /**
   * Generate technical report for developers
   */
  private generateTechnicalReport(
    errors: ProductionError[],
    options: ReportOptions,
    reportId: string
  ): string {
    return JSON.stringify({
      report_id: reportId,
      timestamp: new Date().toISOString(),
      format: 'technical',
      metadata: {
        error_count: errors.length,
        severity: this.calculateOverallSeverity(errors),
        time_range: this.getTimeRange(errors),
        affected_users: this.getAffectedUsers(errors),
        error_types: this.getErrorTypes(errors)
      },
      errors: errors.map(error => ({
        id: error.id,
        timestamp: error.timestamp,
        message: error.error.message,
        stack: error.error.stack,
        type: error.error.type,
        severity: error.error.severity,
        url: error.context.url,
        user_agent: error.context.user_agent,
        organization_id: error.user.organization_id,
        user_role: error.user.role,
        logs: options.includeLogs ? error.logs.slice(0, options.maxLogEntries || 10) : [],
        network: options.includeNetworkRequests ? error.network : [],
        performance: options.includePerformanceMetrics ? error.performance : null
      })),
      analysis: {
        patterns: this.analyzeErrorPatterns(errors),
        recommendations: this.generateRecommendations(errors),
        business_impact: this.calculateBusinessImpact(errors)
      }
    }, null, 2)
  }

  /**
   * Generate business impact report
   */
  private generateBusinessReport(
    errors: ProductionError[],
    options: ReportOptions,
    reportId: string
  ): string {
    const businessImpact = this.calculateBusinessImpact(errors)
    const affectedAreas = this.getAffectedBusinessAreas(errors)
    
    return `
# HERA Business Impact Report

**Report ID:** ${reportId}  
**Date:** ${new Date().toLocaleDateString()}  
**Impact Level:** ${businessImpact.level}

## Business Impact Summary
${businessImpact.description}

## Affected Business Areas
${affectedAreas.map(area => `- ${area.name}: ${area.impact}`).join('\n')}

## Customer Experience Impact
${this.getCustomerImpact(errors)}

## Revenue Impact
${this.getRevenueImpact(errors)}

## Operational Impact
${this.getOperationalImpact(errors)}

## Recommended Actions
${this.getBusinessRecommendations(errors).map(rec => `1. ${rec}`).join('\n')}

---
Report prepared by HERA Production Monitor
    `.trim()
  }

  /**
   * Calculate overall severity from multiple errors
   */
  private calculateOverallSeverity(errors: ProductionError[]): string {
    const severityLevels = ['low', 'medium', 'high', 'critical']
    let maxSeverity = 'low'
    
    errors.forEach(error => {
      const currentIndex = severityLevels.indexOf(error.error.severity)
      const maxIndex = severityLevels.indexOf(maxSeverity)
      
      if (currentIndex > maxIndex) {
        maxSeverity = error.error.severity
      }
    })
    
    return maxSeverity
  }

  /**
   * Generate executive summary
   */
  private generateSummary(errors: ProductionError[]): string {
    const errorCount = errors.length
    const timeRange = this.getTimeRange(errors)
    const affectedUsers = this.getAffectedUsers(errors)
    const topErrorType = this.getMostCommonErrorType(errors)

    return `Between ${timeRange.start} and ${timeRange.end}, HERA detected ${errorCount} production error${errorCount > 1 ? 's' : ''} affecting ${affectedUsers.length} user${affectedUsers.length > 1 ? 's' : ''}. The most common issue was ${topErrorType} errors. Immediate attention is ${this.calculateOverallSeverity(errors) === 'critical' ? 'critical' : 'recommended'}.`
  }

  /**
   * Generate error overview table
   */
  private generateErrorOverview(errors: ProductionError[]): string {
    const errorTypes = this.getErrorTypeCounts(errors)
    
    return `
    <div class="error-overview">
      <table class="error-table">
        <thead>
          <tr>
            <th>Error Type</th>
            <th>Count</th>
            <th>Severity</th>
            <th>Latest Occurrence</th>
          </tr>
        </thead>
        <tbody>
          ${Object.entries(errorTypes).map(([type, data]) => `
            <tr>
              <td>${type}</td>
              <td>${data.count}</td>
              <td><span class="severity-${data.maxSeverity}">${data.maxSeverity}</span></td>
              <td>${data.latestTime}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </div>
    `
  }

  /**
   * Generate detailed error information
   */
  private generateErrorDetail(error: ProductionError, options: ReportOptions): string {
    return `
    <div class="error-detail">
      <div class="error-header">
        <h3>üî¥ ${error.error.type.toUpperCase()} Error</h3>
        <span class="severity-badge severity-${error.error.severity}">${error.error.severity}</span>
      </div>
      
      <div class="error-info">
        <div class="info-grid">
          <div class="info-item">
            <strong>Time:</strong> ${new Date(error.timestamp).toLocaleString()}
          </div>
          <div class="info-item">
            <strong>URL:</strong> <code>${error.context.url}</code>
          </div>
          <div class="info-item">
            <strong>User:</strong> ${error.user.role} (Org: ${error.user.organization_id})
          </div>
          <div class="info-item">
            <strong>Action:</strong> ${error.context.action_being_performed}
          </div>
        </div>
      </div>

      <div class="error-message">
        <h4>Error Message</h4>
        <pre><code>${error.error.message}</code></pre>
      </div>

      ${error.error.stack ? `
        <div class="error-stack">
          <h4>Stack Trace</h4>
          <pre><code>${error.error.stack}</code></pre>
        </div>
      ` : ''}

      ${options.includeLogs && error.logs.length > 0 ? `
        <div class="error-logs">
          <h4>Console Logs</h4>
          <div class="logs">
            ${error.logs.slice(0, options.maxLogEntries || 10).map(log => `
              <div class="log-entry log-${log.level}">
                <span class="log-time">${new Date(log.timestamp).toLocaleTimeString()}</span>
                <span class="log-level">${log.level.toUpperCase()}</span>
                <span class="log-message">${log.message}</span>
              </div>
            `).join('')}
          </div>
        </div>
      ` : ''}
    </div>
    `
  }

  /**
   * Generate performance analysis section
   */
  private generatePerformanceSection(errors: ProductionError[]): string {
    const avgPageLoad = errors.reduce((sum, e) => sum + e.performance.page_load_time, 0) / errors.length
    const avgMemory = errors.reduce((sum, e) => sum + e.performance.memory_usage, 0) / errors.length

    return `
    <section class="section">
      <h2>‚ö° Performance Analysis</h2>
      <div class="performance-metrics">
        <div class="metric-card">
          <h3>Average Page Load</h3>
          <span class="metric-value">${Math.round(avgPageLoad)}ms</span>
        </div>
        <div class="metric-card">
          <h3>Average Memory Usage</h3>
          <span class="metric-value">${Math.round(avgMemory / 1024 / 1024)}MB</span>
        </div>
        <div class="metric-card">
          <h3>Performance Issues</h3>
          <span class="metric-value">${errors.filter(e => e.error.type === 'performance').length}</span>
        </div>
      </div>
    </section>
    `
  }

  /**
   * Generate technical details section
   */
  private generateTechnicalSection(errors: ProductionError[], options: ReportOptions): string {
    return `
    <div class="technical-details">
      <h3>Browser Distribution</h3>
      ${this.generateBrowserDistribution(errors)}
      
      <h3>Error Patterns</h3>
      ${this.generateErrorPatterns(errors)}
      
      <h3>System Information</h3>
      <pre><code>${JSON.stringify(this.getSystemSummary(errors), null, 2)}</code></pre>
    </div>
    `
  }

  /**
   * Generate smart recommendations based on error patterns
   */
  private generateRecommendations(errors: ProductionError[]): string[] {
    const recommendations: string[] = []
    const errorTypes = this.getErrorTypes(errors)
    
    // Authentication errors
    if (errorTypes.authentication > 0) {
      recommendations.push('Review authentication flow and session management')
      recommendations.push('Check token refresh mechanisms')
    }
    
    // API errors
    if (errorTypes.api > 0) {
      recommendations.push('Investigate API endpoint reliability')
      recommendations.push('Review error handling in API calls')
    }
    
    // UI errors
    if (errorTypes.ui > 0) {
      recommendations.push('Review component error boundaries')
      recommendations.push('Test UI components with edge case data')
    }
    
    // Performance errors
    if (errorTypes.performance > 0) {
      recommendations.push('Optimize page load times and memory usage')
      recommendations.push('Review large JavaScript bundles')
    }
    
    // Network errors
    if (errorTypes.network > 0) {
      recommendations.push('Improve offline handling and retry logic')
      recommendations.push('Add network connectivity monitoring')
    }
    
    // Business logic errors
    if (errorTypes.business_logic > 0) {
      recommendations.push('Review business rule validation')
      recommendations.push('Add comprehensive input validation')
    }
    
    // General recommendations
    if (errors.length > 10) {
      recommendations.push('Implement proactive monitoring and alerting')
    }
    
    return recommendations
  }

  /**
   * Helper methods for data analysis
   */
  private getTimeRange(errors: ProductionError[]) {
    const times = errors.map(e => new Date(e.timestamp).getTime())
    return {
      start: new Date(Math.min(...times)).toLocaleString(),
      end: new Date(Math.max(...times)).toLocaleString()
    }
  }

  private getAffectedUsers(errors: ProductionError[]) {
    const users = new Set(errors.map(e => e.user.session_id))
    return Array.from(users)
  }

  private getMostCommonErrorType(errors: ProductionError[]) {
    const types = errors.map(e => e.error.type)
    const counts = types.reduce((acc, type) => {
      acc[type] = (acc[type] || 0) + 1
      return acc
    }, {} as Record<string, number>)
    
    return Object.entries(counts).sort(([,a], [,b]) => b - a)[0][0]
  }

  private getErrorTypes(errors: ProductionError[]) {
    return errors.reduce((acc, error) => {
      acc[error.error.type] = (acc[error.error.type] || 0) + 1
      return acc
    }, {} as Record<string, number>)
  }

  private getErrorTypeCounts(errors: ProductionError[]) {
    return errors.reduce((acc, error) => {
      const type = error.error.type
      if (!acc[type]) {
        acc[type] = {
          count: 0,
          maxSeverity: 'low',
          latestTime: error.timestamp
        }
      }
      
      acc[type].count++
      
      const severityOrder = ['low', 'medium', 'high', 'critical']
      if (severityOrder.indexOf(error.error.severity) > severityOrder.indexOf(acc[type].maxSeverity)) {
        acc[type].maxSeverity = error.error.severity
      }
      
      if (new Date(error.timestamp) > new Date(acc[type].latestTime)) {
        acc[type].latestTime = error.timestamp
      }
      
      return acc
    }, {} as Record<string, any>)
  }

  private getTopIssues(errors: ProductionError[]): string[] {
    const issues = errors
      .filter(e => e.error.severity === 'critical' || e.error.severity === 'high')
      .slice(0, 5)
      .map(e => `${e.error.type}: ${e.error.message.substring(0, 100)}...`)
    
    return issues
  }

  private calculateBusinessImpact(errors: ProductionError[]) {
    const criticalErrors = errors.filter(e => e.error.severity === 'critical').length
    const highErrors = errors.filter(e => e.error.severity === 'high').length
    
    if (criticalErrors > 0) {
      return {
        level: 'High',
        description: `${criticalErrors} critical error${criticalErrors > 1 ? 's' : ''} detected that may prevent core business operations.`
      }
    } else if (highErrors > 0) {
      return {
        level: 'Medium',
        description: `${highErrors} high-priority error${highErrors > 1 ? 's' : ''} detected that may impact user experience.`
      }
    } else {
      return {
        level: 'Low',
        description: 'Minor issues detected with minimal business impact.'
      }
    }
  }

  private getAffectedBusinessAreas(errors: ProductionError[]) {
    const areas = []
    const entityTypes = errors.map(e => e.context.entity_type).filter(Boolean)
    
    if (entityTypes.includes('appointment')) {
      areas.push({ name: 'Appointment Management', impact: 'Booking/scheduling issues' })
    }
    
    if (entityTypes.includes('customer')) {
      areas.push({ name: 'Customer Management', impact: 'Customer data/profile issues' })
    }
    
    return areas
  }

  private getCustomerImpact(errors: ProductionError[]): string {
    const customerFacingErrors = errors.filter(e => 
      e.context.url.includes('/pos/') || 
      e.context.url.includes('/booking/') ||
      e.error.type === 'ui'
    )
    
    if (customerFacingErrors.length > 0) {
      return 'Customer-facing features may be affected, potentially impacting sales and customer satisfaction.'
    }
    
    return 'No direct customer impact detected.'
  }

  private getRevenueImpact(errors: ProductionError[]): string {
    const posErrors = errors.filter(e => e.context.url.includes('/pos/'))
    
    if (posErrors.length > 0) {
      return 'POS system errors detected - potential impact on sales transactions.'
    }
    
    return 'No direct revenue impact identified.'
  }

  private getOperationalImpact(errors: ProductionError[]): string {
    return 'Staff productivity may be affected by system errors and unexpected behavior.'
  }

  private getBusinessRecommendations(errors: ProductionError[]): string[] {
    return [
      'Prioritize fixing critical and high-severity errors',
      'Communicate system status to affected staff',
      'Implement monitoring to prevent similar issues',
      'Review business continuity procedures'
    ]
  }

  private analyzeErrorPatterns(errors: ProductionError[]) {
    return {
      temporal_patterns: this.getTemporalPatterns(errors),
      user_patterns: this.getUserPatterns(errors),
      geographic_patterns: this.getGeographicPatterns(errors)
    }
  }

  private getTemporalPatterns(errors: ProductionError[]) {
    // Analyze when errors occur most frequently
    const hourCounts = errors.reduce((acc, error) => {
      const hour = new Date(error.timestamp).getHours()
      acc[hour] = (acc[hour] || 0) + 1
      return acc
    }, {} as Record<number, number>)
    
    return hourCounts
  }

  private getUserPatterns(errors: ProductionError[]) {
    // Analyze which user roles are most affected
    const roleCounts = errors.reduce((acc, error) => {
      acc[error.user.role] = (acc[error.user.role] || 0) + 1
      return acc
    }, {} as Record<string, number>)
    
    return roleCounts
  }

  private getGeographicPatterns(errors: ProductionError[]) {
    // Analyze geographic distribution (if available)
    return {}
  }

  private generateErrorBreakdown(errors: ProductionError[]): string {
    const breakdown = this.getErrorTypes(errors)
    return Object.entries(breakdown)
      .map(([type, count]) => `- ${type}: ${count} error${count > 1 ? 's' : ''}`)
      .join('\n')
  }

  private generateBrowserDistribution(errors: ProductionError[]): string {
    const browsers = errors.reduce((acc, error) => {
      const userAgent = error.context.user_agent
      let browser = 'Unknown'
      
      if (userAgent.includes('Chrome')) browser = 'Chrome'
      else if (userAgent.includes('Firefox')) browser = 'Firefox'
      else if (userAgent.includes('Safari')) browser = 'Safari'
      else if (userAgent.includes('Edge')) browser = 'Edge'
      
      acc[browser] = (acc[browser] || 0) + 1
      return acc
    }, {} as Record<string, number>)
    
    return Object.entries(browsers)
      .map(([browser, count]) => `${browser}: ${count}`)
      .join(', ')
  }

  private generateErrorPatterns(errors: ProductionError[]): string {
    const patterns = this.analyzeErrorPatterns(errors)
    return JSON.stringify(patterns, null, 2)
  }

  private getSystemSummary(errors: ProductionError[]) {
    return {
      total_errors: errors.length,
      unique_users: new Set(errors.map(e => e.user.session_id)).size,
      time_span: this.getTimeRange(errors),
      error_distribution: this.getErrorTypes(errors)
    }
  }

  /**
   * CSS for HTML reports
   */
  private getReportCSS(): string {
    return `
      body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
      .report-container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
      .report-header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 8px 8px 0 0; }
      .report-header h1 { margin: 0 0 20px 0; }
      .report-meta { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
      .meta-item { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 4px; }
      .label { font-weight: bold; display: block; }
      .value { opacity: 0.9; }
      .severity-critical { background: #dc3545; color: white; padding: 2px 8px; border-radius: 12px; }
      .severity-high { background: #fd7e14; color: white; padding: 2px 8px; border-radius: 12px; }
      .severity-medium { background: #ffc107; color: black; padding: 2px 8px; border-radius: 12px; }
      .severity-low { background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; }
      .section { padding: 30px; border-bottom: 1px solid #eee; }
      .section h2 { margin: 0 0 20px 0; color: #333; }
      .summary-card { background: #f8f9fa; padding: 20px; border-radius: 6px; border-left: 4px solid #007bff; }
      .error-table { width: 100%; border-collapse: collapse; }
      .error-table th, .error-table td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
      .error-table th { background: #f8f9fa; font-weight: 600; }
      .error-detail { background: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #dc3545; }
      .error-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
      .error-header h3 { margin: 0; }
      .severity-badge { padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: bold; }
      .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; margin: 15px 0; }
      .error-message pre, .error-stack pre { background: #f1f3f4; padding: 15px; border-radius: 4px; overflow-x: auto; }
      .logs { max-height: 300px; overflow-y: auto; background: #1a1a1a; padding: 15px; border-radius: 4px; }
      .log-entry { color: #e0e0e0; font-family: monospace; margin: 5px 0; }
      .log-error { color: #ff6b6b; }
      .log-warn { color: #ffd93d; }
      .log-info { color: #6bcf7f; }
      .log-debug { color: #74c0fc; }
      .log-time { color: #888; margin-right: 10px; }
      .log-level { font-weight: bold; margin-right: 10px; min-width: 50px; display: inline-block; }
      .recommendations { background: #e3f2fd; padding: 20px; border-radius: 6px; }
      .recommendation { margin: 10px 0; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid #2196f3; }
      .performance-metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }
      .metric-card { background: #f8f9fa; padding: 20px; border-radius: 6px; text-align: center; }
      .metric-value { font-size: 2em; font-weight: bold; color: #007bff; display: block; }
      .technical-details pre { background: #f1f3f4; padding: 15px; border-radius: 4px; overflow-x: auto; }
      .report-footer { background: #f8f9fa; padding: 20px; text-align: center; color: #666; border-radius: 0 0 8px 8px; }
      @media (max-width: 768px) {
        .report-meta { grid-template-columns: 1fr; }
        .info-grid { grid-template-columns: 1fr; }
        .performance-metrics { grid-template-columns: 1fr; }
      }
    `
  }
}

// Global singleton instance
export const reportGenerator = new ReportGenerator()

export default reportGenerator
/**
 * HERA Universal Factory Test Generator
 * Generates Jest API and Playwright E2E tests from module manifests
 */

import { ModuleManifest } from './universal-factory'
import { writeFile, mkdir } from 'fs/promises'
import { join, dirname } from 'path'

export interface TestGenerationConfig {
  moduleManifest: ModuleManifest
  organizationId: string
  apiBaseUrl: string
  testMatrix: {
    personas?: string[]
    locales?: string[]
    browsers?: string[]
    datasets?: string[]
  }
  ucrPolicies?: Record<string, any>
  guardrailPacks?: string[]
}

export class TestGenerator {
  constructor(private config: TestGenerationConfig) {}

  /**
   * Generate complete test suite for a module
   */
  async generateTestSuite(): Promise<string[]> {
    const generatedFiles: string[] = []

    // Generate shared helpers
    generatedFiles.push(...(await this.generateSharedHelpers()))

    // Generate Jest API tests
    generatedFiles.push(...(await this.generateJestTests()))

    // Generate Playwright E2E tests
    generatedFiles.push(...(await this.generatePlaywrightTests()))

    // Generate configs
    generatedFiles.push(...(await this.generateConfigs()))

    // Generate CI config
    generatedFiles.push(await this.generateCIConfig())

    return generatedFiles
  }

  /**
   * Generate shared test helpers
   */
  private async generateSharedHelpers(): Promise<string[]> {
    const files: string[] = []

    // HTTP helper
    const httpHelper = `/**
 * Shared HTTP helper for tests
 * Auto-generated by HERA Factory
 */

export interface HttpOptions {
  method?: string
  headers?: Record<string, string>
  body?: any
}

export class HttpClient {
  constructor(
    private baseUrl: string,
    private authToken?: string
  ) {}

  async request(path: string, options: HttpOptions = {}): Promise<any> {
    const url = \`\${this.baseUrl}\${path}\`
    
    const response = await fetch(url, {
      method: options.method || 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': this.authToken ? \`Bearer \${this.authToken}\` : '',
        ...options.headers
      },
      body: options.body ? JSON.stringify(options.body) : undefined
    })
    
    if (!response.ok) {
      const error = await response.text()
      throw new Error(\`HTTP \${response.status}: \${error}\`)
    }
    
    return response.json()
  }

  async universalApi(action: string, payload: any): Promise<any> {
    return this.request('/api/v1/universal', {
      method: 'POST',
      body: {
        smart_code: \`HERA.UNIVERSAL.API.\${action.toUpperCase()}.v1_0\`,
        payload
      }
    })
  }
}
`
    files.push(await this.writeTestFile('tests/shared/http.ts', httpHelper))

    // Builder helper
    const builderHelper = `/**
 * Test data builders
 * Auto-generated by HERA Factory
 */

export class TestDataBuilder {
  static createEntity(overrides: Partial<any> = {}) {
    return {
      entity_type: 'test_entity',
      entity_name: 'Test Entity',
      entity_code: \`TEST-\${Date.now()}\`,
      smart_code: '${this.config.moduleManifest.smart_code}',
      metadata: {},
      ...overrides
    }
  }

  static createTransaction(overrides: Partial<any> = {}) {
    return {
      transaction_type: 'test_transaction',
      transaction_code: \`TXN-\${Date.now()}\`,
      smart_code: '${this.config.moduleManifest.smart_code}.TXN.v1',
      total_amount: 100.00,
      metadata: {},
      ...overrides
    }
  }

  static createTransactionLine(transactionId: string, overrides: Partial<any> = {}) {
    return {
      transaction_id: transactionId,
      line_type: 'test_line',
      line_number: 1,
      quantity: 1,
      unit_price: 100.00,
      line_amount: 100.00,
      metadata: {},
      ...overrides
    }
  }

  static generateSmartCode(type: string, subtype: string): string {
    return \`${this.config.moduleManifest.smart_code}.\${type}.\${subtype}.v1\`
  }
}
`
    files.push(await this.writeTestFile('tests/shared/builders.ts', builderHelper))

    // Assertion helper
    const assertionHelper = `/**
 * Custom assertions for HERA tests
 * Auto-generated by HERA Factory
 */

export class Assertions {
  static assertSmartCode(actual: string, pattern: string) {
    const regex = new RegExp(pattern.replace(/\*/g, '.*'))
    expect(actual).toMatch(regex)
  }

  static assertTransaction(transaction: any) {
    expect(transaction).toHaveProperty('id')
    expect(transaction).toHaveProperty('smart_code')
    expect(transaction).toHaveProperty('organization_id')
    expect(transaction).toHaveProperty('created_at')
  }

  static assertEntity(entity: any) {
    expect(entity).toHaveProperty('id')
    expect(entity).toHaveProperty('entity_type')
    expect(entity).toHaveProperty('entity_name')
    expect(entity).toHaveProperty('smart_code')
    expect(entity).toHaveProperty('organization_id')
  }

  static assertGuardrailCompliance(result: any, pack: string) {
    expect(result.guardrail_pack).toBe(pack)
    expect(result.outcome).toMatch(/ALLOW|WARN|BLOCK/)
    if (result.outcome === 'BLOCK') {
      expect(result.violations).toBeInstanceOf(Array)
      expect(result.violations.length).toBeGreaterThan(0)
    }
  }
}
`
    files.push(await this.writeTestFile('tests/shared/assertions.ts', assertionHelper))

    return files
  }

  /**
   * Generate Jest API tests
   */
  private async generateJestTests(): Promise<string[]> {
    const files: string[] = []
    const moduleName = this.config.moduleManifest.name.replace(/\s+/g, '-').toLowerCase()

    // Main API test suite
    const apiTest = `/**
 * ${this.config.moduleManifest.name} API Tests
 * Auto-generated by HERA Factory
 * Smart Code: ${this.config.moduleManifest.smart_code}
 */

import { HttpClient } from '../../shared/http'
import { TestDataBuilder } from '../../shared/builders'
import { Assertions } from '../../shared/assertions'

describe('${this.config.moduleManifest.name} - API Tests', () => {
  let client: HttpClient
  let organizationId: string

  beforeAll(() => {
    const apiUrl = process.env.HERA_API_BASE || '${this.config.apiBaseUrl}'
    const authToken = process.env.HERA_API_TOKEN
    client = new HttpClient(apiUrl, authToken)
    organizationId = '${this.config.organizationId}'
  })

  describe('Module Registration', () => {
    test('should verify module is registered', async () => {
      const response = await client.universalApi('GET_ENTITIES', {
        entity_type: 'module',
        filters: { smart_code: '${this.config.moduleManifest.smart_code}' }
      })

      expect(response.data).toBeDefined()
      expect(response.data.length).toBeGreaterThan(0)
      expect(response.data[0].smart_code).toBe('${this.config.moduleManifest.smart_code}')
    })

    test('should have correct manifest', async () => {
      const response = await client.universalApi('GET_DYNAMIC_DATA', {
        entity_type: 'module',
        field_name: 'module_manifest',
        filters: { smart_code: '${this.config.moduleManifest.smart_code}' }
      })

      const manifest = JSON.parse(response.data[0].field_value_text)
      expect(manifest.name).toBe('${this.config.moduleManifest.name}')
      expect(manifest.version).toBeDefined()
      expect(manifest.entrypoints).toBeDefined()
    })
  })

  describe('Entity Operations', () => {
    let createdEntityId: string

    test('should create entity via universal API', async () => {
      const entity = TestDataBuilder.createEntity({
        entity_type: '${moduleName}_entity',
        entity_name: 'Test ${this.config.moduleManifest.name} Entity',
        organization_id: organizationId
      })

      const response = await client.universalApi('CREATE_ENTITY', entity)
      
      expect(response.success).toBe(true)
      Assertions.assertEntity(response.data)
      createdEntityId = response.data.id
    })

    test('should retrieve entity with correct smart code', async () => {
      const response = await client.universalApi('GET_ENTITY', {
        entity_id: createdEntityId
      })

      Assertions.assertSmartCode(response.data.smart_code, '${this.config.moduleManifest.smart_code}.*')
    })

    test('should update entity', async () => {
      const updates = {
        entity_name: 'Updated ${this.config.moduleManifest.name} Entity',
        metadata: { updated: true, timestamp: new Date().toISOString() }
      }

      const response = await client.universalApi('UPDATE_ENTITY', {
        entity_id: createdEntityId,
        updates
      })

      expect(response.success).toBe(true)
      expect(response.data.entity_name).toBe(updates.entity_name)
    })

    test('should add dynamic fields', async () => {
      const dynamicFields = [
        { name: 'custom_field_1', value: 'test_value_1', type: 'text' },
        { name: 'custom_field_2', value: 123.45, type: 'number' }
      ]

      for (const field of dynamicFields) {
        const response = await client.universalApi('SET_DYNAMIC_FIELD', {
          entity_id: createdEntityId,
          field_name: field.name,
          field_value: field.value,
          smart_code: TestDataBuilder.generateSmartCode('FIELD', field.name.toUpperCase())
        })

        expect(response.success).toBe(true)
      }
    })

    test('should delete entity', async () => {
      const response = await client.universalApi('DELETE_ENTITY', {
        entity_id: createdEntityId
      })

      expect(response.success).toBe(true)
    })
  })

  describe('Transaction Operations', () => {
    let transactionId: string

    test('should create transaction with lines', async () => {
      const transaction = TestDataBuilder.createTransaction({
        transaction_type: '${moduleName}_transaction',
        organization_id: organizationId
      })

      const response = await client.universalApi('CREATE_TRANSACTION', {
        transaction,
        lines: [
          TestDataBuilder.createTransactionLine('temp-id', {
            line_type: '${moduleName}_line',
            metadata: { test: true }
          })
        ]
      })

      expect(response.success).toBe(true)
      Assertions.assertTransaction(response.data)
      transactionId = response.data.id
    })

    test('should validate transaction smart codes', async () => {
      const response = await client.universalApi('GET_TRANSACTION', {
        transaction_id: transactionId
      })

      Assertions.assertSmartCode(
        response.data.smart_code,
        '${this.config.moduleManifest.smart_code}.TXN.*'
      )
    })
  })

  describe('Guardrail Compliance', () => {
    ${this.config.guardrailPacks
      ?.map(
        pack => `
    test('should comply with ${pack} guardrails', async () => {
      const response = await client.universalApi('EVALUATE_GUARDRAILS', {
        context: {
          organization_id: organizationId,
          module_smart_code: '${this.config.moduleManifest.smart_code}',
          guardrail_pack: '${pack}'
        }
      })

      Assertions.assertGuardrailCompliance(response.data, '${pack}')
    })
    `
      )
      .join('\n')}
  })

  describe('Contract Tests', () => {
    ${this.config.moduleManifest.entrypoints.api
      .map(
        endpoint => `
    test('should validate ${endpoint} contract', async () => {
      // Contract test for ${endpoint}
      const response = await client.request('${endpoint}', {
        method: endpoint.startsWith('POST') ? 'POST' : 'GET'
      })

      expect(response).toBeDefined()
      // Add specific contract assertions based on OpenAPI spec
    })
    `
      )
      .join('\n')}
  })
})
`
    files.push(await this.writeTestFile(`tests/api/${moduleName}/${moduleName}.spec.ts`, apiTest))

    // Performance test
    const perfTest = `/**
 * ${this.config.moduleManifest.name} Performance Tests
 * Auto-generated by HERA Factory
 */

import { HttpClient } from '../../shared/http'

describe('${this.config.moduleManifest.name} - Performance Tests', () => {
  let client: HttpClient

  beforeAll(() => {
    client = new HttpClient(
      process.env.HERA_API_BASE || '${this.config.apiBaseUrl}',
      process.env.HERA_API_TOKEN
    )
  })

  test('should handle concurrent requests', async () => {
    const concurrency = 10
    const requests = Array(concurrency).fill(null).map(() =>
      client.universalApi('GET_ENTITIES', {
        entity_type: 'module',
        limit: 10
      })
    )

    const startTime = Date.now()
    const results = await Promise.all(requests)
    const duration = Date.now() - startTime

    expect(results).toHaveLength(concurrency)
    expect(duration).toBeLessThan(5000) // 5 seconds for 10 concurrent requests
  })

  test('should handle large payloads', async () => {
    const largeEntity = {
      entity_type: 'test_large',
      entity_name: 'Large Entity',
      metadata: {
        data: Array(1000).fill(null).map((_, i) => ({
          index: i,
          value: \`Value \${i}\`,
          timestamp: new Date().toISOString()
        }))
      }
    }

    const startTime = Date.now()
    const response = await client.universalApi('CREATE_ENTITY', largeEntity)
    const duration = Date.now() - startTime

    expect(response.success).toBe(true)
    expect(duration).toBeLessThan(2000) // 2 seconds for large payload
  })
})
`
    files.push(await this.writeTestFile(`tests/api/${moduleName}/performance.spec.ts`, perfTest))

    return files
  }

  /**
   * Generate Playwright E2E tests
   */
  private async generatePlaywrightTests(): Promise<string[]> {
    const files: string[] = []
    const moduleName = this.config.moduleManifest.name.replace(/\s+/g, '-').toLowerCase()

    // Main E2E test
    const e2eTest = `/**
 * ${this.config.moduleManifest.name} E2E Tests
 * Auto-generated by HERA Factory
 * Tests DNA UI Components: ${this.config.moduleManifest.entrypoints.ui.join(', ')}
 */

import { test, expect, Page } from '@playwright/test'

test.describe('${this.config.moduleManifest.name} - E2E Tests', () => {
  let page: Page

  test.beforeEach(async ({ page: p }) => {
    page = p
    // Navigate to base URL
    await page.goto(process.env.DNA_BASE_URL || '${this.config.apiBaseUrl}')
    
    // Login if required
    if (await page.locator('input[name="email"]').isVisible()) {
      await test.step('Login', async () => {
        await page.fill('input[name="email"]', process.env.TEST_USER_EMAIL || 'test@example.com')
        await page.fill('input[name="password"]', process.env.TEST_USER_PASSWORD || 'password')
        await page.click('button[type="submit"]')
        await page.waitForURL('**/dashboard')
      })
    }
  })

  ${this.config.moduleManifest.entrypoints.ui
    .map((component, index) => {
      const componentName = component.replace('dna:', '')
      const route = this.getRouteForComponent(componentName)

      return `
  test.describe('${componentName} Component', () => {
    test('should render ${componentName}', async () => {
      await test.step('Navigate to ${componentName}', async () => {
        await page.goto('${route}')
        await page.waitForLoadState('networkidle')
      })

      await test.step('Verify component loaded', async () => {
        // Wait for DNA component to render
        await expect(page.locator('[data-component="${componentName}"]')).toBeVisible()
        
        // Take screenshot for visual regression
        await page.screenshot({
          path: \`artifacts/screenshots/${moduleName}-${componentName}.png\`,
          fullPage: true
        })
      })
    })

    test('should be accessible', async () => {
      await page.goto('${route}')
      
      // Run accessibility checks
      const violations = await page.evaluate(async () => {
        // @ts-ignore
        const results = await window.axe.run()
        return results.violations
      })

      expect(violations).toHaveLength(0)
    })

    ${this.generatePersonaTests(componentName)}
  })
  `
    })
    .join('\n')}

  test.describe('Cross-Component Flows', () => {
    test('should complete end-to-end workflow', async () => {
      // Example workflow through multiple components
      ${this.generateE2EWorkflow()}
    })
  })

  test.describe('Responsive Design', () => {
    ${(this.config.testMatrix.browsers || ['chromium'])
      .map(
        browser => `
    test('should work on ${browser}', async ({ browser }) => {
      const context = await browser.newContext({
        viewport: this.getViewportForBrowser('${browser}')
      })
      const page = await context.newPage()
      
      await page.goto('${this.getRouteForComponent(this.config.moduleManifest.entrypoints.ui[0].replace('dna:', ''))}')
      await expect(page.locator('[data-component]')).toBeVisible()
      
      await page.screenshot({
        path: \`artifacts/screenshots/${moduleName}-${browser}.png\`
      })
    })
    `
      )
      .join('\n')}
  })
})
`
    files.push(await this.writeTestFile(`tests/e2e/${moduleName}/${moduleName}.spec.ts`, e2eTest))

    // Accessibility test
    const a11yTest = `/**
 * ${this.config.moduleManifest.name} Accessibility Tests
 * Auto-generated by HERA Factory
 */

import { test, expect } from '@playwright/test'
import { injectAxe, checkA11y } from 'axe-playwright'

test.describe('${this.config.moduleManifest.name} - Accessibility', () => {
  ${this.config.moduleManifest.entrypoints.ui
    .map(component => {
      const componentName = component.replace('dna:', '')
      const route = this.getRouteForComponent(componentName)

      return `
  test('${componentName} should pass WCAG checks', async ({ page }) => {
    await page.goto('${route}')
    await injectAxe(page)
    
    const violations = await checkA11y(page, undefined, {
      detailedReport: true,
      detailedReportOptions: {
        html: true
      }
    })

    // Save detailed report
    if (violations) {
      await page.screenshot({
        path: \`artifacts/a11y/${moduleName}-${componentName}-violations.png\`
      })
    }

    expect(violations).toBeNull()
  })
  `
    })
    .join('\n')}
})
`
    files.push(await this.writeTestFile(`tests/e2e/${moduleName}/accessibility.spec.ts`, a11yTest))

    return files
  }

  /**
   * Generate test configurations
   */
  private async generateConfigs(): Promise<string[]> {
    const files: string[] = []

    // Jest config
    const jestConfig = `import type { Config } from 'jest'

const config: Config = {
  displayName: '${this.config.moduleManifest.name} API Tests',
  testEnvironment: 'node',
  roots: ['<rootDir>/tests/api'],
  testMatch: ['**/*.spec.ts'],
  transform: {
    '^.+\\\\.(ts|tsx)$': ['ts-jest', {
      tsconfig: 'tsconfig.json'
    }]
  },
  collectCoverage: true,
  coverageDirectory: 'artifacts/coverage',
  coverageReporters: ['json', 'lcov', 'text', 'html'],
  coverageThreshold: {
    global: {
      branches: ${this.config.ucrPolicies?.coverage_min || 80},
      functions: ${this.config.ucrPolicies?.coverage_min || 80},
      lines: ${this.config.ucrPolicies?.coverage_min || 80},
      statements: ${this.config.ucrPolicies?.coverage_min || 80}
    }
  },
  reporters: [
    'default',
    ['jest-junit', {
      outputDirectory: 'artifacts/junit',
      outputName: 'jest-junit.xml',
      classNameTemplate: '{classname}',
      titleTemplate: '{title}',
      ancestorSeparator: ' › '
    }]
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts']
}

export default config
`
    files.push(await this.writeTestFile('jest.config.ts', jestConfig))

    // Playwright config
    const playwrightConfig = `import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: 'tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  timeout: 60 * 1000,
  
  reporter: [
    ['html', { outputFolder: 'artifacts/pw-report', open: 'never' }],
    ['junit', { outputFile: 'artifacts/pw-junit.xml' }],
    ['list']
  ],

  use: {
    baseURL: process.env.DNA_BASE_URL || '${this.config.apiBaseUrl}',
    trace: 'retain-on-failure',
    video: 'retain-on-failure',
    screenshot: 'only-on-failure',
    actionTimeout: 30 * 1000,
  },

  projects: [
    ${(this.config.testMatrix.browsers || ['chromium'])
      .map(
        browser => `
    {
      name: '${browser}',
      use: { ...devices['${this.getDeviceForBrowser(browser)}'] },
    }`
      )
      .join(',')}
  ],

  outputDir: 'artifacts/test-results/',

  webServer: process.env.CI ? undefined : {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
})
`
    files.push(await this.writeTestFile('playwright.config.ts', playwrightConfig))

    // Test setup
    const setupFile = `/**
 * Test setup file
 * Auto-generated by HERA Factory
 */

// Add any global test setup here
beforeAll(() => {
  // Set longer timeout for API calls in tests
  jest.setTimeout(30000)
})

// Clean up after tests
afterAll(async () => {
  // Add cleanup logic if needed
})
`
    files.push(await this.writeTestFile('tests/setup.ts', setupFile))

    // Package.json scripts
    const packageScripts = {
      test: 'npm run test:api && npm run test:e2e',
      'test:api': 'jest --config jest.config.ts',
      'test:e2e': 'playwright test',
      'test:contract': "jest --testMatch='**/contract/**/*.spec.ts'",
      'test:watch': 'jest --watch',
      'test:coverage': 'jest --coverage',
      'test:e2e:headed': 'playwright test --headed',
      'test:e2e:debug': 'playwright test --debug',
      'test:e2e:ui': 'playwright test --ui'
    }

    return files
  }

  /**
   * Generate CI configuration
   */
  private async generateCIConfig(): Promise<string> {
    const ciConfig = `name: ${this.config.moduleManifest.name} Tests
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  HERA_API_BASE: \${{ secrets.HERA_API_BASE }}
  HERA_API_TOKEN: \${{ secrets.HERA_API_TOKEN }}
  DNA_BASE_URL: \${{ secrets.DNA_BASE_URL }}
  TEST_USER_EMAIL: \${{ secrets.TEST_USER_EMAIL }}
  TEST_USER_PASSWORD: \${{ secrets.TEST_USER_PASSWORD }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [20.x]
        
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: \${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Install Playwright browsers
      run: npx playwright install --with-deps
    
    - name: Run API tests
      run: npm run test:api
      
    - name: Run E2E tests
      run: npm run test:e2e
    
    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report
        path: artifacts/coverage/
        retention-days: 30
    
    - name: Upload Playwright report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: playwright-report
        path: artifacts/pw-report/
        retention-days: 30
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          artifacts/junit/
          artifacts/pw-junit.xml
          artifacts/screenshots/
          artifacts/videos/
          artifacts/traces/
        retention-days: 30
    
    - name: Report to HERA Factory
      if: always()
      run: |
        # Report test results back to factory
        curl -X POST "\${{ env.HERA_API_BASE }}/api/v1/universal" \\
          -H "Authorization: Bearer \${{ env.HERA_API_TOKEN }}" \\
          -H "Content-Type: application/json" \\
          -d '{
            "smart_code": "HERA.UNIVERSAL.FACTORY.TEST.REPORT.v1_0",
            "payload": {
              "module_smart_code": "${this.config.moduleManifest.smart_code}",
              "pipeline_id": "\${{ github.run_id }}",
              "status": "\${{ job.status }}",
              "artifacts": {
                "coverage_uri": "\${{ steps.upload-coverage.outputs.artifact-url }}",
                "report_uri": "\${{ steps.upload-playwright.outputs.artifact-url }}"
              }
            }
          }'
`

    return await this.writeTestFile('.github/workflows/test.yml', ciConfig)
  }

  // Helper methods
  private async writeTestFile(path: string, content: string): Promise<string> {
    const fullPath = join(process.cwd(), path)
    await mkdir(dirname(fullPath), { recursive: true })
    await writeFile(fullPath, content, 'utf-8')
    return path
  }

  private getRouteForComponent(componentName: string): string {
    // Simple mapping - in real implementation would use route config
    return `/${componentName
      .toLowerCase()
      .replace(/([A-Z])/g, '-$1')
      .replace(/^-/, '')}`
  }

  private getDeviceForBrowser(browser: string): string {
    const deviceMap = {
      chromium: 'Desktop Chrome',
      firefox: 'Desktop Firefox',
      webkit: 'Desktop Safari',
      'mobile-chrome': 'Pixel 5',
      'mobile-safari': 'iPhone 13'
    }
    return deviceMap[browser] || 'Desktop Chrome'
  }

  private getViewportForBrowser(browser: string): { width: number; height: number } {
    if (browser.includes('mobile')) {
      return { width: 375, height: 667 }
    }
    return { width: 1280, height: 720 }
  }

  private generatePersonaTests(componentName: string): string {
    return (this.config.testMatrix.personas || ['user'])
      .map(
        persona => `
    test('should work for ${persona} persona', async () => {
      // Set persona context
      await page.evaluate((p) => {
        window.localStorage.setItem('test-persona', p)
      }, '${persona}')
      
      await page.reload()
      
      // Verify persona-specific UI elements
      if ('${persona}' === 'admin') {
        await expect(page.locator('[data-admin-only]')).toBeVisible()
      } else {
        await expect(page.locator('[data-admin-only]')).not.toBeVisible()
      }
    })
    `
      )
      .join('\n')
  }

  private generateE2EWorkflow(): string {
    // Generate a basic workflow based on UI components
    return `
      // Navigate to first component
      await page.goto('${this.getRouteForComponent(this.config.moduleManifest.entrypoints.ui[0].replace('dna:', ''))}')
      
      // Perform action
      await page.click('[data-action="create"]')
      
      // Fill form
      await page.fill('input[name="name"]', 'Test Item')
      await page.fill('input[name="amount"]', '100.00')
      
      // Submit
      await page.click('button[type="submit"]')
      
      // Verify success
      await expect(page.locator('[data-success-message]')).toBeVisible()
      
      // Navigate to details
      await page.click('[data-item-link]')
      
      // Verify navigation
      await expect(page).toHaveURL(/\\/\\d+$/)
    `
  }
}

/**
 * Generate test suite for a module
 */
export async function generateModuleTests(config: TestGenerationConfig): Promise<string[]> {
  const generator = new TestGenerator(config)
  return await generator.generateTestSuite()
}

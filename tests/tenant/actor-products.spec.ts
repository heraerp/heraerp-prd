/**
 * Products Actor Stamping Tests
 * 
 * Generated by HERA Hook-Driven Module Generator
 * Tests actor stamping coverage for products
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { createClient } from '@supabase/supabase-js'

describe('Products Actor Stamping', () => {
  let supabase: any
  let testOrgId: string

  beforeAll(async () => {
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )
    testOrgId = process.env.TEST_ORGANIZATION_ID!
  })

  it('should stamp created_by and updated_by on entity creation', async () => {
    // Create test products via API v2 command
    const createResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.TEST_JWT_TOKEN}`,
        'X-Organization-Id': testOrgId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "CREATE",
        p_data: {
          entity_type: "PRODUCT",
          entity_name: "Actor Test Products",
          smart_code: "HERA.RETAIL.PRODUCT.v1",
          organization_id: testOrgId
        }
      })
    })

    expect(createResponse.status).toBe(200)
    const { data: createdProducts } = await createResponse.json()

    // Verify actor stamps in database
    const { data: entity } = await supabase
      .from('core_entities')
      .select('created_by, updated_by, created_at, updated_at')
      .eq('id', createdProducts.entity_id)
      .single()

    expect(entity.created_by).toBeDefined()
    expect(entity.updated_by).toBeDefined()
    expect(entity.created_at).toBeDefined()
    expect(entity.updated_at).toBeDefined()
    expect(entity.created_by).toBe(entity.updated_by) // Same actor for creation
  })

  it('should update updated_by on entity modification', async () => {
    // Create test products
    const createResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.TEST_JWT_TOKEN}`,
        'X-Organization-Id': testOrgId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "CREATE",
        p_data: {
          entity_type: "PRODUCT",
          entity_name: "Update Test Products",
          smart_code: "HERA.RETAIL.PRODUCT.v1",
          organization_id: testOrgId
        }
      })
    })

    const { data: createdProducts } = await createResponse.json()
    const originalCreatedBy = createdProducts.created_by

    // Update the products
    const updateResponse = await fetch('/api/v2/command', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.TEST_JWT_TOKEN}`,
        'X-Organization-Id': testOrgId,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        op: "entities",
        p_operation: "UPDATE",
        p_data: {
          entity_id: createdProducts.entity_id,
          entity_type: "PRODUCT",
          entity_name: "Updated Test Products",
          smart_code: "HERA.RETAIL.PRODUCT.v1",
          organization_id: testOrgId
        }
      })
    })

    expect(updateResponse.status).toBe(200)

    // Verify updated_by is stamped
    const { data: updatedEntity } = await supabase
      .from('core_entities')
      .select('created_by, updated_by, created_at, updated_at')
      .eq('id', createdProducts.entity_id)
      .single()

    expect(updatedEntity.created_by).toBe(originalCreatedBy) // Should not change
    expect(updatedEntity.updated_by).toBeDefined()
    expect(new Date(updatedEntity.updated_at)).toBeGreaterThan(new Date(updatedEntity.created_at))
  })

  it('should maintain â‰¥95% actor coverage across Sacred Six tables', async () => {
    // Check coverage in core_entities
    const { data: entities, count: totalEntities } = await supabase
      .from('core_entities')
      .select('created_by', { count: 'exact' })
      .eq('entity_type', 'PRODUCT')
      .eq('organization_id', testOrgId)

    const entitiesWithActors = entities?.filter(e => e.created_by !== null).length || 0
    const entityCoverage = totalEntities ? (entitiesWithActors / totalEntities) * 100 : 0

    expect(entityCoverage).toBeGreaterThanOrEqual(95)

    // Check coverage in core_dynamic_data
    const { data: dynamicData, count: totalDynamic } = await supabase
      .from('core_dynamic_data')
      .select('created_by, entity_id', { count: 'exact' })
      .eq('organization_id', testOrgId)
      .in('entity_id', entities?.map(e => e.id) || [])

    const dynamicWithActors = dynamicData?.filter(d => d.created_by !== null).length || 0
    const dynamicCoverage = totalDynamic ? (dynamicWithActors / totalDynamic) * 100 : 0

    expect(dynamicCoverage).toBeGreaterThanOrEqual(95)

    console.log(`Products Actor Coverage:
      - Entities: ${entityCoverage.toFixed(1)}% (${entitiesWithActors}/${totalEntities})
      - Dynamic Data: ${dynamicCoverage.toFixed(1)}% (${dynamicWithActors}/${totalDynamic})`)
  })

  it('should prevent actor-less writes', async () => {
    // This test ensures the RPC functions reject writes without actor context
    // In practice, this should be caught by the API v2 gateway before reaching RPC
    
    const { error } = await supabase.rpc('hera_entities_crud_v1', {
      p_action: 'CREATE',
      // p_actor_user_id missing
      p_organization_id: testOrgId,
      p_entity: {
        entity_type: 'PRODUCT',
        entity_name: 'No Actor Products',
        smart_code: 'HERA.RETAIL.PRODUCT.v1'
      },
      p_dynamic: {},
      p_relationships: [],
      p_options: {}
    })

    expect(error).toBeDefined()
    expect(error.message).toMatch(/actor/i)
  })
})
